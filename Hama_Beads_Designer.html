<!doctype html>
<html lang="pt-BR">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Hama Beads Designer (offline)</title>
    <style>
        :root {
            --ui-text: #e5e7eb;
            --ui-muted: #94a3b8;
            --ui-border: rgba(255, 255, 255, .12);
            --btn: rgba(255, 255, 255, .08);
            --btn-hover: rgba(255, 255, 255, .12);
            --accent: #60a5fa;
            --danger: #fb7185;
            --ok: #34d399;
            --field-bg: rgba(0, 0, 0, .90);
            --field-bg-2: rgba(0, 0, 0, .30);
        }

        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
            background: #0f172a;
            color: var(--ui-text);

            display: grid;
            grid-template-columns: 340px 1fr 300px;
            grid-template-rows: auto 1fr auto;
            grid-template-areas:
                "top top top"
                "left main right"
                "bottom bottom bottom";
            height: 100vh;
            overflow: hidden;
        }

        #topbar {
            grid-area: top;
            border-bottom: 1px solid var(--ui-border);
            background: linear-gradient(180deg, rgba(255, 255, 255, .05), rgba(255, 255, 255, 0));
            position: sticky;
            top: 0;
            z-index: 20;
        }

        header {
            padding: 10px 16px;
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            align-items: center;
            gap: 12px;
        }

        .brand {
            display: flex;
            flex-direction: column;
            gap: 2px;
            justify-self: start;
        }

        header h1 {
            font-size: 14px;
            margin: 0;
            font-weight: 650;
            letter-spacing: .2px;
        }

        .muted {
            color: var(--ui-muted);
            font-size: 12px;
        }

        #docInfo {
            justify-self: center;
            text-align: center;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 60vw;
        }

        #btnHelp {
            justify-self: end;
        }

        .toolbar {
            padding: 8px 16px 10px;
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 10px 12px;
            border-top: 1px solid rgba(255, 255, 255, .06);
            border-bottom: 1px solid rgba(255, 255, 255, .06);
        }

        .toolbar .group {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 8px;
            padding-right: 12px;
            border-right: 1px solid rgba(255, 255, 255, .08);
            margin-right: 2px;
        }

        .toolbar .group:last-child {
            border-right: none;
            padding-right: 0;
            margin-right: 0;
        }

        label {
            font-size: 12px;
            color: var(--ui-muted);
            display: inline-flex;
            align-items: center;
            gap: 8px;
            white-space: nowrap;
        }

        input[type="range"] {
            width: 180px;
            accent-color: var(--accent);
        }

        input[type="number"],
        input[type="text"],
        input[type="search"],
        select {
            background: var(--field-bg);
            border: 1px solid var(--ui-border);
            color: var(--ui-text);
            outline: none;
        }

        input[type="number"] {
            width: 92px;
            padding: 7px 8px;
            border-radius: 10px;
        }

        /* --- Pixel Editor Toolbar Styles --- */
        .pixel-editor-toolbar {
            display: flex;
            flex-direction: row;
            gap: 8px;
            align-items: center;
        }

        .tool-group {
            display: flex;
            flex-direction: row;
            gap: 4px;
            border-right: 1px solid var(--ui-border);
            padding-right: 8px;
            margin-right: 4px;
            align-items: center;
        }

        .tool-group:last-child {
            border-right: none;
            padding-right: 0;
            margin-right: 0;
        }

        .tool-button {
            background-color: var(--btn);
            border: none;
            border-radius: 6px;
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
            padding: 0;
            position: relative;
        }

        .tool-button:hover {
            background-color: var(--btn-hover);
        }

        .tool-button:active {
            transform: scale(0.95);
        }

        .tool-button.active {
            background-color: var(--accent);
        }

        .tool-button svg {
            width: 20px;
            height: 20px;
            stroke: var(--ui-text);
            stroke-width: 2;
            stroke-linecap: round;
            stroke-linejoin: round;
            fill: none;
        }

        .tool-button.active svg {
            stroke: #fff;
        }

        .tool-button[title]:hover::after {
            content: attr(title);
            position: absolute;
            bottom: 42px;
            left: 50%;
            transform: translateX(-50%);
            background: #000;
            color: #fff;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            white-space: nowrap;
            z-index: 100;
        }

        select {
            padding: 7px 8px;
            border-radius: 10px;
        }

        button {
            background: var(--btn);
            border: 1px solid var(--ui-border);
            color: var(--ui-text);
            padding: 8px 10px;
            border-radius: 10px;
            cursor: pointer;
            font-size: 12px;
            white-space: nowrap;
        }

        button:hover {
            background: var(--btn-hover);
        }

        button.primary {
            border-color: rgba(96, 165, 250, .45);
            background: rgba(96, 165, 250, .15);
        }

        /* Dropdown Menu Styles */
        .dropdown {
            position: relative;
            display: inline-block;
        }

        .dropdown-toggle {
            font-weight: 500;
        }

        .dropdown-content {
            display: none;
            position: absolute;
            top: calc(100% + 5px);
            left: 0;
            background: rgba(15, 23, 42, 0.95);
            backdrop-filter: blur(10px);
            border: 1px solid var(--ui-border);
            border-radius: 12px;
            min-width: 200px;
            box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.5);
            z-index: 1000;
            padding: 6px;
        }

        .dropdown-content button {
            width: 100%;
            text-align: left;
            background: transparent !important;
            border: none !important;
            border-radius: 8px;
            padding: 10px 12px;
            font-size: 13px;
            margin-bottom: 2px;
            display: block;
        }

        .dropdown-content button:hover {
            background: var(--btn-hover) !important;
        }

        .dropdown-content hr {
            border: 0;
            border-top: 1px solid var(--ui-border);
            margin: 6px 4px;
        }

        .dropdown.show .dropdown-content {
            display: block;
            animation: dropdownFadeIn 0.15s ease-out;
        }

        @keyframes dropdownFadeIn {
            from {
                opacity: 0;
                transform: translateY(-8px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        button.danger {
            border-color: rgba(251, 113, 133, .45);
            background: rgba(251, 113, 133, .14);
        }

        button.ok {
            border-color: rgba(52, 211, 153, .45);
            background: rgba(52, 211, 153, .14);
        }

        .kbd {
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
            font-size: 11px;
            color: rgba(255, 255, 255, .88);
            border: 1px solid var(--ui-border);
            background: rgba(255, 255, 255, .05);
            padding: 2px 6px;
            border-radius: 7px;
        }

        aside#left {
            grid-area: left;
            border-right: 1px solid var(--ui-border);
            background: linear-gradient(180deg, rgba(255, 255, 255, .03), rgba(255, 255, 255, 0));
            overflow: auto;
        }

        .palette {
            padding: 12px 14px 14px;
        }

        .palette h2 {
            margin: 0 0 8px 0;
            font-size: 13px;
            font-weight: 650;
        }

        .palette .tools {
            display: flex;
            gap: 8px;
            align-items: center;
            flex-wrap: wrap;
            margin-bottom: 10px;
        }

        .palette input[type="search"] {
            flex: 1;
            min-width: 150px;
            padding: 8px 10px;
            border-radius: 10px;
        }

        .swatches {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 6px;
        }

        .swatch {
            display: grid;
            place-items: center;
            padding: 5px 4px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, .10);
            background: rgba(255, 255, 255, .035);
            cursor: pointer;
            user-select: none;
            overflow: hidden;
        }

        .swatch[aria-selected="true"] {
            outline: 2px solid rgba(96, 165, 250, .85);
            outline-offset: 1px;
            border-color: rgba(96, 165, 250, .5);
        }

        .swatch.manage-selected {
            outline: 2px solid rgba(96, 165, 250, .85);
            outline-offset: 1px;
            border-color: rgba(96, 165, 250, .5);
        }

        .chip {
            width: 18px;
            height: 18px;
            border-radius: 999px;
            border: 1px solid rgba(0, 0, 0, .35);
            box-shadow: inset 0 0 0 1px rgba(255, 255, 255, .08);
            background: var(--c);
        }

        .swatch small {
            margin-top: 4px;
            font-size: 10px;
            color: rgba(255, 255, 255, .92);
            line-height: 1.05;
            text-align: center;
            word-break: break-word;
        }

        main {
            grid-area: main;
            overflow: hidden;
            min-width: 0;
        }

        .canvasWrap {
            height: 100%;
            overflow: auto;
            background:

                #0b1224;
            position: relative;
        }

        canvas#board {
            display: block;
            margin: 16px;
            background: rgba(255, 255, 255, .03);
            border: 1px solid var(--ui-border);
            border-radius: 12px;
            image-rendering: pixelated;
            box-shadow: 0 10px 30px rgba(0, 0, 0, .35);
        }

        .overlay {
            position: absolute;
            inset: 0;
            display: none;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, .45);
            backdrop-filter: blur(2px);
            z-index: 40;
        }

        .overlay.show {
            display: flex;
        }

        .overlayCard {
            border: 1px solid rgba(255, 255, 255, .18);
            background: rgba(15, 23, 42, .90);
            border-radius: 14px;
            padding: 14px 16px;
            min-width: 260px;
            display: flex;
            align-items: center;
            gap: 12px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, .55);
        }

        .spinner {
            width: 18px;
            height: 18px;
            border-radius: 999px;
            border: 2px solid rgba(255, 255, 255, .22);
            border-top-color: rgba(255, 255, 255, .80);
            animation: spin 0.9s linear infinite;
            flex: 0 0 auto;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        .overlayText {
            display: flex;
            flex-direction: column;
            gap: 2px;
            min-width: 0;
        }

        .overlayText strong {
            font-size: 12px;
            font-weight: 650;
        }

        .overlayText span {
            font-size: 12px;
            color: var(--ui-muted);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 340px;
        }

        aside#right {
            grid-area: right;
            border-left: 1px solid var(--ui-border);
            background: linear-gradient(180deg, rgba(255, 255, 255, .03), rgba(255, 255, 255, 0));
            overflow: auto;
            position: relative;
        }

        body.right-collapsed {
            grid-template-columns: 340px 1fr 0px;
        }

        body.right-collapsed aside#right {
            overflow: hidden;
            border-left: none;
            display: none;
        }

        .rightToggleFixed {
            position: fixed;
            right: 10px;
            top: 172px;
            width: 34px;
            height: 46px;
            border-radius: 12px;
            border: 1px solid var(--ui-border);
            background: rgba(0, 0, 0, .28);
            display: grid;
            place-items: center;
            cursor: pointer;
            user-select: none;
            z-index: 50;
            box-shadow: 0 10px 25px rgba(0, 0, 0, .35);
        }

        .rightToggleFixed:hover {
            background: rgba(0, 0, 0, .38);
        }

        .chev {
            font-size: 14px;
            color: rgba(255, 255, 255, .85);
        }

        .rightPanel {
            padding: 12px 12px 14px;
        }

        .rightPanel h2 {
            margin: 0 0 8px 0;
            font-size: 13px;
            font-weight: 650;
        }

        .usedSummary {
            display: flex;
            justify-content: space-between;
            gap: 10px;
            flex-wrap: wrap;
            margin-bottom: 10px;
            color: var(--ui-muted);
            font-size: 12px;
        }

        .usedList {
            display: grid;
            gap: 6px;
        }

        .usedItem {
            border: 1px solid rgba(255, 255, 255, .10);
            background: rgba(255, 255, 255, .035);
            border-radius: 12px;
            padding: 7px 8px;
            display: grid;
            grid-template-columns: 18px 1fr auto;
            gap: 10px;
            align-items: center;
        }

        .usedItem .chip {
            width: 14px;
            height: 14px;
            border-radius: 999px;
            border: 1px solid rgba(0, 0, 0, .35);
            cursor: pointer;
        }

        .usedMeta {
            display: flex;
            flex-direction: column;
            gap: 1px;
            min-width: 0;
        }

        .usedMeta .name {
            font-size: 12px;
            color: rgba(255, 255, 255, .92);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            cursor: pointer;
        }

        .usedMeta .hex {
            font-size: 11px;
            color: rgba(255, 255, 255, .55);
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
            line-height: 1.1;
        }

        .usedActions {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .usedActions .count {
            font-size: 12px;
            color: rgba(255, 255, 255, .8);
            min-width: 28px;
            text-align: right;
        }

        .usedActions button {
            padding: 6px 8px;
            border-radius: 10px;
            font-size: 11px;
            height: 28px;
        }

        footer#bottom {
            grid-area: bottom;
            border-top: 1px solid var(--ui-border);
            background: rgba(11, 18, 36, 0.95);
            padding: 8px 16px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            z-index: 30;
        }

        .footerControls {
            display: flex;
            align-items: center;
            gap: 16px;
            padding: 0;
            margin: 0;
        }

        .footerControls .group {
            border: none;
            padding: 0;
            margin: 0;
        }

        .footerControls label {
            color: var(--ui-text);
            font-weight: 500;
        }

        .footerControls select,
        .footerControls input[type="range"] {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 6px;
            padding: 4px 8px;
            height: 28px;
        }

        .footerControls input[type="range"] {
            width: 120px;
        }

        #cellSizeLabel {
            display: inline-block;
            width: 40px;
            text-align: right;
            font-variant-numeric: tabular-nums;
        }

        #statusLeft,
        #statusRight {
            color: var(--ui-muted);
            font-size: 12px;
        }

        #statusRight {
            display: flex;
            justify-content: flex-end;
            align-items: center;
            flex: 1;
        }

        dialog {
            border: 1px solid var(--ui-border);
            border-radius: 16px;
            padding: 0;
            background: #0b1224;
            color: var(--ui-text);
            width: min(920px, calc(100vw - 24px));
            box-shadow: 0 20px 60px rgba(0, 0, 0, .6);
        }

        dialog::backdrop {
            background: rgba(0, 0, 0, .55);
        }

        .dlgHead {
            padding: 14px 16px;
            border-bottom: 1px solid var(--ui-border);
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
        }

        .dlgHead strong {
            font-size: 13px;
        }

        .dlgBody {
            padding: 14px 16px;
        }

        .grid2 {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
        }

        .grid2 .full {
            grid-column: 1 / -1;
        }

        .hint {
            color: var(--ui-muted);
            font-size: 12px;
            line-height: 1.45;
        }

        .help-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        .help-section h3 {
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--ui-text);
            margin-bottom: 10px;
            padding-bottom: 4px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }

        .help-list {
            list-style: none;
            padding: 0;
            margin: 0;
            display: grid;
            gap: 8px;
        }

        .help-list li {
            display: flex;
            align-items: center;
            justify-content: space-between;
            font-size: 12px;
            color: var(--ui-muted);
        }

        .help-list li .label {
            flex: 1;
        }

        .field {
            display: grid;
            gap: 6px;
            align-content: start;
        }

        .field input[type="text"] {
            width: 100%;
            padding: 8px 10px;
            border-radius: 10px;
            background: var(--field-bg);
            border: 1px solid var(--ui-border);
            color: var(--ui-text);
            outline: none;
        }

        .field input[type="color"] {
            width: 100%;
            padding: 6px 8px;
            border-radius: 10px;
            background: var(--field-bg-2);
            border: 1px solid var(--ui-border);
            color: var(--ui-text);
            outline: none;
        }

        .dlgFoot {
            padding: 14px 16px;
            border-top: 1px solid var(--ui-border);
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            flex-wrap: wrap;
        }

        /* ===== Converter Layout 2-Col ===== */
        .convertLayout {
            display: grid;
            grid-template-columns: 340px 1fr;
            gap: 14px;
            height: 75vh;
            max-height: 800px;
        }

        #dlgImgToBeads {
            width: 90vw;
            max-width: 1400px;
            height: 85vh;
            max-height: 95vh;
            resize: both;
            overflow: hidden !important;
            /* Important to override default dialog behavior if needed */
            min-width: 600px;
            min-height: 500px;
            display: none;
            /* Hide by default */
            flex-direction: column;
        }

        #dlgImgToBeads[open] {
            display: flex;
            /* Only flex when open */
        }

        #dlgImgToBeads .dlgBody {
            flex: 1;
            overflow: hidden;
            padding: 14px;
            display: flex;
            flex-direction: column;
        }

        /* Override convertLayout to fill the dialog body */
        #dlgImgToBeads .convertLayout {
            height: 100%;
            max-height: none;
        }

        /* Left Panel: Source + Controls */
        .convertLeftPanel {
            display: flex;
            flex-direction: column;
            gap: 14px;
            min-height: 0;
        }

        .convertSource {
            display: grid;
            grid-template-rows: auto 1fr auto;
            gap: 8px;
            border: 1px solid rgba(255, 255, 255, .10);
            background: rgba(255, 255, 255, .03);
            border-radius: 12px;
            padding: 10px;
            height: 250px;
            /* fixed height for source image area */
        }

        .convertControls {
            border: 1px solid rgba(255, 255, 255, .10);
            background: rgba(255, 255, 255, .03);
            border-radius: 12px;
            padding: 12px;
            overflow-y: auto;
            flex: 1;
            /* controls take remaining space */
        }

        /* Right Panel: Preview only */
        .convertDest {
            display: grid;
            grid-template-rows: auto 1fr auto;
            gap: 8px;
            border: 1px solid rgba(255, 255, 255, .10);
            background: rgba(255, 255, 255, .03);
            border-radius: 12px;
            padding: 10px;
            min-height: 0;
        }

        .convertCanvasWrap {
            position: relative;
            border: 1px solid rgba(255, 255, 255, .12);
            background: rgba(0, 0, 0, .20);
            border-radius: 10px;
            overflow: auto;
            /* Allow scrolling */
            height: 100%;
            min-height: 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .convertCanvasWrap canvas {
            display: block;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }

        /* Dense grid for controls */
        .convertControls .grid2-dense {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px 10px;
        }

        .convertControls label {
            font-size: 11px;
            margin-bottom: 2px;
        }

        .convertControls input[type="number"],
        .convertControls select {
            font-size: 12px;
            padding: 4px;
            height: 24px;
        }

        .convertControls .field {
            margin-bottom: 0;
        }

        .convertControls .hint {
            font-size: 10px;
            margin-top: 2px;
            line-height: 1.2;
        }

        .convertControls input[type=checkbox] {
            width: 14px;
            height: 14px;
            vertical-align: middle;
        }

        /* ===== Gerenciar cores com imagem à esquerda ===== */
        .manageLayout {
            display: grid;
            grid-template-columns: 380px 1fr;
            gap: 14px;
            align-items: start;
        }

        .manageLeft {
            border: 1px solid rgba(255, 255, 255, .10);
            background: rgba(255, 255, 255, .03);
            border-radius: 14px;
            padding: 10px;
            display: grid;
            gap: 10px;
        }

        .manageRight {
            min-width: 0;
        }

        .imgTools {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 8px;
        }

        .imgTools input[type="file"] {
            display: none;
        }

        .imgTools .mini {
            padding: 7px 10px;
            border-radius: 10px;
            font-size: 12px;
        }

        .imgCanvasWrap {
            position: relative;
            border: 1px solid rgba(255, 255, 255, .12);
            background: rgba(0, 0, 0, .20);
            border-radius: 12px;
            overflow: hidden;
            height: 360px;
            min-height: 300px;
        }

        canvas#manageImgCanvas {
            width: 100%;
            height: 100%;
            display: block;
            cursor: crosshair;
            /* esquerdo = pegar/aplicar cor */
        }

        canvas#manageImgCanvas.panning {
            cursor: grabbing;
            /* direito = pan */
        }

        .imgBottom {
            display: grid;
            grid-template-columns: 1fr auto;
            gap: 10px;
            align-items: center;
        }

        .sampleBox {
            display: flex;
            align-items: center;
            gap: 10px;
            min-width: 0;
        }

        .sampleDot {
            width: 18px;
            height: 18px;
            border-radius: 999px;
            border: 1px solid rgba(0, 0, 0, .35);
            box-shadow: inset 0 0 0 1px rgba(255, 255, 255, .08);
            background: var(--c, #ffffff);
            flex: 0 0 auto;
        }

        .sampleMeta {
            display: flex;
            flex-direction: column;
            gap: 2px;
            min-width: 0;
        }

        .sampleMeta .hex {
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
            font-size: 11px;
            color: rgba(255, 255, 255, .75);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .sampleMeta .note {
            font-size: 11px;
            color: var(--ui-muted);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .tinyRange {
            width: 160px !important;
        }

        .applyRow {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            align-items: end;
        }

        .applyRow .field input[type="text"] {
            padding: 7px 9px;
        }

        .applyBtns {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            justify-content: flex-end;
        }
    </style>
</head>

<body>
    <div id="topbar">
        <header>
            <div class="brand">
                <h1>Hama Beads Designer</h1>
                <div class="muted">HTML único, funciona offline.</div>
            </div>

            <div class="muted" id="docInfo"></div>

            <button class="primary" id="btnHelp" title="Atalhos e dicas">Ajuda</button>
        </header>

        <div class="toolbar">
            <div class="group">
                <div class="dropdown" id="dropdownArquivo">
                    <button class="dropdown-toggle">Arquivo ▾</button>
                    <div class="dropdown-content">
                        <button id="btnNewProject" class="danger">Novo Projeto</button>
                        <button id="btnOpen">Abrir Projeto... <span class="kbd"
                                style="float:right">Ctrl+O</span></button>
                        <button id="btnSave" class="ok">Salvar Projeto <span class="kbd"
                                style="float:right">Ctrl+S</span></button>
                        <hr>
                        <button id="btnExportPng">Exportar como PNG</button>
                        <button id="btnImgToBeads" class="primary">Importar Imagem → Beads</button>
                    </div>
                </div>
                <input id="fileOpen" type="file" accept=".json,.hama,.hama.json,application/json" hidden />
            </div>

            <div class="group">
                <div class="dropdown" id="dropdownEditar">
                    <button class="dropdown-toggle">Editar ▾</button>
                    <div class="dropdown-content">
                        <button id="btnUndo">Desfazer <span class="kbd" style="float:right">Ctrl+Z</span></button>
                        <button id="btnRedo">Refazer <span class="kbd" style="float:right">Ctrl+Y</span></button>
                        <hr>
                        <button id="btnResize">Redimensionar Board...</button>
                        <button id="btnClear" class="danger">Limpar Tudo <span class="kbd"
                                style="float:right">Delete</span></button>
                        <hr>
                        <button id="btnResetView">Centralizar Visualização</button>
                    </div>
                </div>
            </div>

            <div class="group">
                <div class="dropdown" id="dropdownPaleta">
                    <button class="dropdown-toggle">Paleta ▾</button>
                    <div class="dropdown-content">
                        <button class="btnAddColorAction" class="primary">Adicionar Nova Cor</button>
                        <button id="btnManageColors">Gerenciar Paleta...</button>
                        <hr>
                        <button id="btnSavePalette">Exportar Paleta (.json)</button>
                        <button id="btnLoadPalette">Importar Paleta (.json)</button>
                    </div>
                </div>
            </div>

            <div class="pixel-editor-toolbar" id="mainToolbar">
                <div class="tool-group">
                    <button class="tool-button active" data-tool="paint" title="Lápis (Pencil) [B]">
                        <svg viewBox="0 0 24 24">
                            <path d="M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z"></path>
                            <path d="m15 5 4 4"></path>
                        </svg>
                    </button>
                    <button class="tool-button" data-tool="erase" title="Borracha (Eraser) [E]">
                        <svg viewBox="0 0 24 24">
                            <path
                                d="m7 21-4.3-4.3c-1-1-1-2.5 0-3.4l9.6-9.6c1-1 2.5-1 3.4 0l5.6 5.6c1 1 1 2.5 0 3.4L13 21Z">
                            </path>
                            <path d="M22 21H7"></path>
                            <path d="m5 11 9 9"></path>
                        </svg>
                    </button>
                    <button class="tool-button" data-tool="bucket" title="Balde de Tinta (Bucket Fill) [F]">
                        <svg viewBox="0 0 24 24">
                            <path d="M19 11l-9 9-9-9 9-9 9 9Z" />
                            <path d="M15 7l4 4" />
                            <path d="m5 13 4 4" />
                            <path d="m21 15 .01.01" />
                            <path d="M21 15c0 1.1-.9 2-2 2s-2-.9-2-2c0-2 2-4 2-4s2 2 2 4Z" />
                        </svg>
                    </button>
                    <button class="tool-button" data-tool="picker" title="Conta-gotas (Color Picker) [I]">
                        <svg viewBox="0 0 24 24">
                            <path d="M7.5 20.5 14 14 10 10 3.5 16.5 2 22 7.5 20.5Z" />
                            <path d="M9.56 9.69C18.12-5.25 29.44 5.53 14.34 14.44Z" fill="currentColor"
                                fill-opacity="0.15" />
                            <path />
                        </svg>
                    </button>
                </div>

                <div class="tool-group">
                    <button class="tool-button" data-tool="line" title="Linha (Line Tool)">
                        <svg viewBox="0 0 24 24">
                            <path d="M5 19 19 5"></path>
                        </svg>
                    </button>
                    <button class="tool-button" data-tool="rect" title="Retângulo (Rectangle)">
                        <svg viewBox="0 0 24 24">
                            <rect width="18" height="14" x="3" y="5" rx="2"></rect>
                        </svg>
                    </button>
                    <button class="tool-button" data-tool="ellipse" title="Elipse (Ellipse)">
                        <svg viewBox="0 0 24 24">
                            <circle cx="12" cy="12" r="10"></circle>
                        </svg>
                    </button>
                    <button class="tool-button" data-tool="polygon" title="Polígono (Polygon Tool) [P]">
                        <svg viewBox="0 0 24 24">
                            <path d="M12 2 2 12l10 10 10-10Z"></path>
                        </svg>
                    </button>
                </div>

                <div class="tool-group">
                    <button class="tool-button" data-tool="rectSelect" title="Seleção Retangular [M]">
                        <svg viewBox="0 0 24 24" style="stroke-dasharray: 4 4;">
                            <rect width="18" height="18" x="3" y="3" rx="2"></rect>
                        </svg>
                    </button>
                    <button class="tool-button" data-tool="lassoSelect" title="Laço (Free Selection) [L]">
                        <svg viewBox="0 0 24 24" style="stroke-dasharray: 4 4;">
                            <path d="M12 3c-5 0-9 4-9 7s3 6 3 9 3 2 6 2 6-2 6-5-3-6-3-9 2-4 2-4-2-0-5 0z" />
                        </svg>
                    </button>
                </div>

                <div class="tool-group">
                    <button class="tool-button" data-tool="flip-h" title="Inverter Horizontal">
                        <svg viewBox="0 0 24 24">
                            <path d="M8 22l-6-10 6-10" />
                            <path d="M16 2l6 10-6 10" />
                            <line x1="12" y1="2" x2="12" y2="22" stroke-dasharray="2 2" />
                        </svg>
                    </button>
                    <button class="tool-button" data-tool="flip-v" title="Inverter Vertical">
                        <svg viewBox="0 0 24 24">
                            <path d="M2 8l10-6 10 6" />
                            <path d="M22 16l-10 6-10-6" />
                            <line x1="2" y1="12" x2="22" y2="12" stroke-dasharray="2 2" />
                        </svg>
                    </button>
                    <button class="tool-button" data-tool="rotate" title="Girar 90°">
                        <svg viewBox="0 0 24 24">
                            <path d="M23 4v6h-6" />
                            <path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10" />
                        </svg>
                    </button>
                </div>
            </div>

            <div class="group">
                <label>
                    <input id="chkMirror" type="checkbox" /> Espelhar
                </label>
                <label title="Preencher formas geométricas (Retângulo, Elipse, Polígono)">
                    <input type="checkbox" id="chkFill" /> Preencher
                </label>
            </div>
        </div>
    </div>

    <aside id="left">
        <div class="palette">


            <div class="tools">
                <h2>Paleta</h2>
                <input id="palSearch" type="search" placeholder="Filtrar por ref. (ex.: 2-C2, 1-A1)..." />
                <button id="btnAddColorSidebar" class="btnAddColorAction primary">Adic. Cor</button>
                <input id="fileOpenPalette" type="file" accept=".json,.palette.json,application/json" hidden />
            </div>

            <div class="swatches" id="swatches"></div>


        </div>
    </aside>

    <main>
        <div class="canvasWrap" id="canvasWrap">
            <canvas id="board" width="800" height="600"></canvas>

            <div class="overlay" id="loadingOverlay" aria-live="polite" aria-busy="true">
                <div class="overlayCard">
                    <div class="spinner"></div>
                    <div class="overlayText">
                        <strong>Carregando arquivo...</strong>
                        <span id="loadingFileName">Aguarde</span>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <aside id="right">
        <div class="rightPanel">
            <h2>Cores usadas</h2>
            <div class="usedSummary">
                <div id="usedTotal">Total: 0</div>
                <div id="usedUnique">Únicas: 0</div>
            </div>
            <div class="usedList" id="usedList"></div>

            <div class="hint" style="margin-top:10px">
                Clique na bolinha ou no nome para selecionar a cor. “Substituir” troca no projeto (todas as
                ocorrências).
            </div>
        </div>
    </aside>

    <div class="rightToggleFixed" id="rightToggle" title="Recolher/expandir painel de cores usadas">
        <div class="chev" id="rightChev">❯</div>
    </div>

    <footer id="bottom">
        <div id="statusLeft" class="muted"></div>

        <div id="statusRight" class="muted">
            <div class="footerControls">
                <div class="group">
                    <label>Modo
                        <select id="viewMode">
                            <option value="round">Redondo (bead)</option>
                            <option value="pixel">Quadrado (pixel)</option>
                            <option value="melted">Finalizado (melt)</option>
                        </select>
                    </label>
                </div>

                <div class="group">
                    <label>Zoom
                        <input id="cellSize" type="range" min="6" max="42" value="18" />
                        <span id="cellSizeLabel" class="muted">18 px</span>
                    </label>
                </div>
            </div>
        </div>
    </footer>

    <dialog id="dlgResize">
        <div class="dlgHead">
            <strong>Dimensionar board</strong>
            <button id="dlgResizeClose">Fechar</button>
        </div>
        <div class="dlgBody">
            <div class="grid2">
                <div class="field">
                    <label>Linhas</label>
                    <input id="resizeRows" type="number" min="1" max="400" />
                </div>
                <div class="field">
                    <label>Colunas</label>
                    <input id="resizeCols" type="number" min="1" max="400" />
                </div>
                <div class="field full">
                    <label><input id="resizeKeep" type="checkbox" checked /> Manter o trabalho atual (copiar para o
                        canto superior esquerdo)</label>
                    <div class="hint">Se desmarcar, um board novo e vazio será criado.</div>
                </div>
            </div>
        </div>
        <div class="dlgFoot">
            <button class="primary" id="dlgResizeApply">Aplicar</button>
        </div>
    </dialog>

    <dialog id="dlgColor">
        <div class="dlgHead">
            <strong id="dlgColorTitle">Adicionar cor</strong>
            <button id="dlgColorClose">Fechar</button>
        </div>
        <div class="dlgBody">
            <div class="grid2">
                <div class="field">
                    <label>Nome</label>
                    <input id="colorName" type="text" placeholder="Ex.: 1-A1, 2-C2..." />
                </div>
                <div class="field">
                    <label>Cor</label>
                    <input id="colorHex" type="color" value="#ffffff" />
                </div>
                <div class="field full">
                    <div class="hint">
                        Para manter o padrão, use <strong>Imagem-Coord</strong> (ex.: <strong>1-A1</strong>).
                    </div>
                </div>
            </div>
        </div>
        <div class="dlgFoot">
            <button id="dlgColorDelete" class="danger" style="display:none">Remover</button>
            <button class="primary" id="dlgColorSave">Salvar</button>
        </div>
    </dialog>

    <dialog id="dlgManage">
        <div class="dlgHead">
            <strong>Gerenciar cores</strong>
            <button id="dlgManageClose">Fechar</button>
        </div>
        <div class="dlgBody">
            <div class="manageLayout">
                <div class="manageLeft">
                    <div class="imgTools">
                        <button class="mini primary" id="btnLoadManageImg">Carregar imagem</button>
                        <input id="manageImgFile" type="file" accept="image/*" />
                        <button class="mini" id="btnManageResetView">Reset view</button>

                        <label style="margin-left:auto">Zoom
                            <input class="tinyRange" id="manageImgZoom" type="range" min="10" max="600" value="100" />
                            <span class="muted" id="manageImgZoomLbl">100%</span>
                        </label>
                    </div>

                    <div class="imgTools">
                        <div class="muted">
                            Esquerdo: pega e <strong>aplica</strong> cor. Direito: arrastar/mover. Roda do mouse: zoom.
                        </div>
                    </div>

                    <div class="imgCanvasWrap">
                        <canvas id="manageImgCanvas"></canvas>
                    </div>

                    <div class="imgBottom">
                        <div class="sampleBox">
                            <div class="sampleDot" id="manageSampleDot" style="--c:#ffffff"></div>
                            <div class="sampleMeta">
                                <div class="hex" id="manageSampleHex">#ffffff</div>
                                <div class="note" id="manageSampleNote">Selecione uma cor na lista e clique na imagem.
                                </div>
                            </div>
                        </div>
                        <input id="manageSampleColor" type="color" value="#ffffff" title="Ajustar cor" />
                    </div>

                    <div class="applyRow">
                        <div class="field">
                            <label>Nome para nova cor</label>
                            <input id="manageNewColorName" type="text" placeholder="Ex.: 2-C2, 1-A1..." />
                        </div>
                        <div class="applyBtns">
                            <button id="btnAddFromSample" class="ok">Adicionar cor</button>
                        </div>
                    </div>

                    <div class="hint">
                        A cor clicada na imagem é aplicada automaticamente na <strong>cor selecionada</strong> à
                        direita.
                        Para criar uma nova cor: clique na imagem (captura) → digite nome → “Adicionar cor”.
                    </div>
                </div>

                <div class="manageRight">
                    <div class="hint"
                        style="margin-bottom:10px; display:flex; align-items:center; justify-content:space-between; gap:10px;">
                        <div>
                            Clique em uma cor para <strong>selecionar</strong>. Duplo clique para editar nome/cor.
                        </div>
                        <button id="btnDeleteAllColors" class="danger" title="Remove todas as cores da paleta">
                            Deletar paleta
                        </button>
                    </div>

                    <div class="swatches" id="manageSwatches"></div>
                </div>

            </div>
        </div>
        <div class="dlgFoot">
            <button id="dlgManageDone" class="primary">Concluir</button>
        </div>
    </dialog>

    <dialog id="dlgReplace">
        <div class="dlgHead">
            <strong>Substituir cor no projeto</strong>
            <button id="dlgReplaceClose">Fechar</button>
        </div>
        <div class="dlgBody">
            <div class="grid2">
                <div class="field full">
                    <div class="hint" id="replaceFromText"></div>
                </div>
                <div class="field full">
                    <label>Substituir por</label>
                    <div class="swatches" id="replaceSwatches"></div>
                </div>
            </div>
        </div>
        <div class="dlgFoot" style="justify-content:space-between">
            <button class="danger" id="dlgReplaceDelete">Apagar cor no grid</button>
            <button class="primary" id="dlgReplaceApply">Aplicar</button>
        </div>
    </dialog>

    <dialog id="dlgHelp">
        <div class="dlgHead">
            <strong>Ajuda rápida</strong>
            <button id="dlgHelpClose">Fechar</button>
        </div>
        <div class="dlgBody">
            <div class="help-grid">
                <div class="help-section">
                    <h3>Atalhos de Teclado</h3>
                    <ul class="help-list">
                        <li><span class="label">Pincel / Pintar</span> <span class="kbd">B</span></li>
                        <li><span class="label">Borracha</span> <span class="kbd">E</span></li>
                        <li><span class="label">Balde de Tinta</span> <span class="kbd">F</span></li>
                        <li><span class="label">Conta-gotas</span> <span class="kbd">I</span></li>
                        <li><span class="label">Polígono</span> <span class="kbd">P</span></li>
                        <li><span class="label">Seleção Retangular</span> <span class="kbd">M</span></li>
                        <li><span class="label">Seleção Livre (Laço)</span> <span class="kbd">L</span></li>
                        <li>
                            <hr style="border:0; border-top:1px solid rgba(255,255,255,0.05); width:100%; margin:4px 0">
                        </li>
                        <li><span class="label">Desfazer</span> <span class="kbd">Ctrl+Z</span></li>
                        <li><span class="label">Refazer</span> <span class="kbd">Ctrl+Y</span></li>
                        <li><span class="label">Salvar Projeto</span> <span class="kbd">Ctrl+S</span></li>
                        <li><span class="label">Abrir Projeto</span> <span class="kbd">Ctrl+O</span></li>
                        <li><span class="label">Limpar Seleção</span> <span class="kbd">Escape</span></li>
                    </ul>
                </div>
                <div class="help-section">
                    <h3>Mouse & Interação</h3>
                    <ul class="help-list">
                        <li><span class="label">Pintar / Usar ferramenta</span> <span>Botão Esquerdo</span></li>
                        <li><span class="label">Apagar (Borracha rápida)</span> <span>Botão Direito</span></li>
                        <li><span class="label">Desenhar linha reta</span> <span class="kbd">Shift</span> + Arrastar
                        </li>
                        <li><span class="label">Mover Seleção</span> <span>Setas do Teclado</span></li>
                        <li><span class="label">Confirmar Polígono</span> <span class="kbd">Enter</span></li>
                    </ul>
                    <h3 style="margin-top:20px">Dicas Rápidas</h3>
                    <div class="hint">
                        • <strong>Gerenciar Cores</strong> permite extrair cores de uma imagem carregada.<br>
                        • <strong>Exportar PNG</strong> gera uma imagem pronta para impressão com lista de
                        materiais.<br>
                        • Use o <strong>Balde</strong> para preencher áreas da mesma cor rapidamente.
                    </div>
                </div>
            </div>
        </div>
        <div class="dlgFoot">
            <button id="dlgHelpOk" class="primary">OK</button>
        </div>
    </dialog>

    <dialog id="dlgImgToBeads">
        <div class="dlgHead">
            <strong>Converter imagem em beads</strong>
            <button id="dlgImgToBeadsClose">Fechar</button>
        </div>

        <div class="dlgBody">
            <div class="convertLayout">
                <!-- LEFT COLUMN: Source + Controls -->
                <div class="convertLeftPanel">
                    <!-- Source Image -->
                    <div class="convertSource">
                        <div class="imgTools">
                            <button class="mini primary" id="btnLoadConvertImg">Carregar</button>
                            <input id="convertImgFile" type="file" accept="image/*" />
                            <button class="mini" id="btnConvertResetView">Reset</button>

                            <label style="margin-left:auto; font-size:11px">Zoom
                                <input class="tinyRange" id="convertImgZoom" type="range" min="10" max="600" value="100"
                                    style="width:60px!important" />
                                <span class="muted" id="convertImgZoomLbl">100%</span>
                            </label>
                        </div>
                        <div class="convertCanvasWrap" style="overflow:hidden">
                            <canvas id="convertImgCanvas"></canvas>
                        </div>
                        <div class="hint" id="convertStats"
                            style="white-space:nowrap; overflow:hidden; text-overflow:ellipsis"
                            title="Estatísticas da conversão">
                            Img: -
                        </div>
                    </div>

                    <!-- Controls (Compact) -->
                    <div class="convertControls">
                        <div class="field full">
                            <label>Modo de cores</label>
                            <select id="convertColorMode">
                                <option value="usePalette">Usar paleta atual</option>
                                <option value="quantizeNew">Gerar paleta (K-Means)</option>
                            </select>
                        </div>

                        <div class="field full">
                            <label>Lado maior (beads)</label>
                            <div style="display:flex; gap:8px;">
                                <input id="convertMaxSide" type="number" min="8" max="400" value="48"
                                    style="width:80px" />
                                <label style="display:flex; align-items:center; gap:4px; margin:0;">
                                    <input id="convertLockAspect" type="checkbox" checked /> Manter proporção
                                </label>
                            </div>
                        </div>

                        <div class="hint" style="margin-bottom:4px">Auto linhas/colunas</div>
                        <div class="grid2-dense">
                            <div class="field">
                                <label>Colunas</label>
                                <input id="convertCols" type="number" min="1" max="400" value="48" />
                            </div>
                            <div class="field">
                                <label>Linhas</label>
                                <input id="convertRows" type="number" min="1" max="400" value="48" />
                            </div>
                            <div class="field">
                                <label>Cores (K)</label>
                                <input id="convertK" type="number" min="2" max="96" value="16" />
                            </div>
                            <div class="field">
                                <label>Iterações</label>
                                <input id="convertIters" type="number" min="3" max="30" value="10" />
                            </div>
                        </div>

                        <div class="field full" style="margin-top:6px;">
                            <label><input id="convertDither" type="checkbox" /> Dithering (Floyd–Storm)</label>
                        </div>
                        <div class="field full">
                            <label><input id="convertReplacePalette" type="checkbox" /> Substituir paleta se
                                gerar</label>
                        </div>

                        <div class="field full"
                            style="margin-top:10px; padding-top:10px; border-top:1px solid rgba(255,255,255,.10);">
                            <label><input id="convertAutoApply" type="checkbox" checked /> Atualizar auto</label>
                            <div class="hint" style="margin-bottom:6px">Se lento, desmarque.</div>

                            <div style="display:flex; gap:6px; justify-content:space-between">
                                <button id="btnConvertPreview" style="flex:1">Gerar Preview</button>
                                <button id="btnConvertApply" class="ok" style="flex:1">Aplicar</button>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- RIGHT COLUMN: Large Preview -->
                <div class="convertDest">
                    <div class="imgTools" style="justify-content:space-between">
                        <label style="font-size:11px">
                            Visualizar:
                            <select id="convertPreviewMode" style="padding:4px; border-radius:6px; font-size:11px">
                                <option value="melted" selected>Melted (Finalizado)</option>
                                <option value="round">Beads (Redondo)</option>
                                <option value="pixel">Pixels (Quadrado)</option>
                            </select>
                        </label>

                        <label style="font-size:11px">Zoom
                            <input id="convertPreviewCellSize" type="range" min="2" max="28" value="8" class="tinyRange"
                                style="width:100px!important" />
                            <span class="muted" id="convertPreviewCellSizeLbl">8 px</span>
                        </label>
                    </div>

                    <div class="convertCanvasWrap">
                        <canvas id="convertBeadsPreviewCanvas" style="image-rendering:pixelated;"></canvas>
                    </div>

                    <div class="hint" style="text-align:right">
                        Resultado da conversão
                    </div>
                </div>
            </div>
        </div>

        <div class="dlgFoot">
            <button class="primary" id="dlgImgToBeadsDone">Concluir</button>
        </div>
    </dialog>


    <script>
        (() => {
            function uid() { return Math.random().toString(16).slice(2) + Date.now().toString(16); }
            function clampInt(v, a, b) {
                v = Number(v);
                if (!Number.isFinite(v)) v = a;
                v = Math.round(v);
                return Math.max(a, Math.min(b, v));
            }
            function normalizeHex(hex) {
                if (!hex) return "";
                hex = String(hex).trim();
                if (!hex.startsWith("#")) hex = "#" + hex;
                if (/^#[0-9a-fA-F]{3}$/.test(hex)) {
                    const r = hex[1], g = hex[2], b = hex[3];
                    return ("#" + r + r + g + g + b + b).toLowerCase();
                }
                if (/^#[0-9a-fA-F]{6}$/.test(hex)) return hex.toLowerCase();
                return "";
            }
            function sanitizeFileBaseName(name) {
                name = String(name || "").trim();
                if (!name) return "hama";
                name = name.replace(/[\\/:*?"<>|]+/g, "-").trim();
                if (!name) name = "hama";
                return name;
            }

            // ===== Paletas base =====

            // Paleta completa das 3 imagens (mantida como "Paleta completa")
            const FULL_PALETTE = [{ "id": "1-A1", "name": "1-A1", "color": "#3a9bd3" }, { "id": "1-A2", "name": "1-A2", "color": "#cc0d13" }, { "id": "1-A3", "name": "1-A3", "color": "#b487cf" }, { "id": "1-A4", "name": "1-A4", "color": "#cce5fb" }, { "id": "1-B1", "name": "1-B1", "color": "#2b6f5b" }, { "id": "1-B2", "name": "1-B2", "color": "#8833a8" }, { "id": "1-B3", "name": "1-B3", "color": "#7ad1a3" }, { "id": "1-B4", "name": "1-B4", "color": "#e9b9c8" }, { "id": "1-C1", "name": "1-C1", "color": "#3c2e2b" }, { "id": "1-C2", "name": "1-C2", "color": "#dad44f" }, { "id": "1-C3", "name": "1-C3", "color": "#37b6c5" }, { "id": "1-C4", "name": "1-C4", "color": "#d7739f" }, { "id": "1-D1", "name": "1-D1", "color": "#c7533f" }, { "id": "1-D2", "name": "1-D2", "color": "#7c6c6c" }, { "id": "1-D3", "name": "1-D3", "color": "#d9d7d6" }, { "id": "1-D4", "name": "1-D4", "color": "#cdb12a" }, { "id": "1-E1", "name": "1-E1", "color": "#1d2e56" }, { "id": "1-E2", "name": "1-E2", "color": "#e76c26" }, { "id": "1-E3", "name": "1-E3", "color": "#c8aa46" }, { "id": "1-E4", "name": "1-E4", "color": "#d5a08a" }, { "id": "1-F1", "name": "1-F1", "color": "#c2a12e" }, { "id": "1-F2", "name": "1-F2", "color": "#58362a" }, { "id": "1-F3", "name": "1-F3", "color": "#cf2c2b" }, { "id": "1-F4", "name": "1-F4", "color": "#9b8b8a" }, { "id": "2-A1", "name": "2-A1", "color": "#c92c2e" }, { "id": "2-A2", "name": "2-A2", "color": "#d9c6d3" }, { "id": "2-A3", "name": "2-A3", "color": "#b35e54" }, { "id": "2-A4", "name": "2-A4", "color": "#3aa0d4" }, { "id": "2-B1", "name": "2-B1", "color": "#e16b2c" }, { "id": "2-B2", "name": "2-B2", "color": "#d0c581" }, { "id": "2-B3", "name": "2-B3", "color": "#b02d32" }, { "id": "2-B4", "name": "2-B4", "color": "#d88aa3" }, { "id": "2-C1", "name": "2-C1", "color": "#d7b9a5" }, { "id": "2-C2", "name": "2-C2", "color": "#df6e2f" }, { "id": "2-C3", "name": "2-C3", "color": "#9ebedc" }, { "id": "2-C4", "name": "2-C4", "color": "#b7a2c8" }, { "id": "2-D1", "name": "2-D1", "color": "#d17590" }, { "id": "2-D2", "name": "2-D2", "color": "#7c3a94" }, { "id": "2-D3", "name": "2-D3", "color": "#8fb7b0" }, { "id": "2-D4", "name": "2-D4", "color": "#e0a82f" }, { "id": "2-E1", "name": "2-E1", "color": "#4a9a6b" }, { "id": "2-E2", "name": "2-E2", "color": "#1d2e56" }, { "id": "2-E3", "name": "2-E3", "color": "#cdb02e" }, { "id": "2-E4", "name": "2-E4", "color": "#dcb5ad" }, { "id": "2-F1", "name": "2-F1", "color": "#4f2b7b" }, { "id": "2-F2", "name": "2-F2", "color": "#1b63ad" }, { "id": "2-F3", "name": "2-F3", "color": "#3aa0d3" }, { "id": "2-F4", "name": "2-F4", "color": "#d4c6b6" }, { "id": "3-A1", "name": "3-A1", "color": "#e88a2a" }, { "id": "3-A2", "name": "3-A2", "color": "#49a5d9" }, { "id": "3-A3", "name": "3-A3", "color": "#c56b8f" }, { "id": "3-A4", "name": "3-A4", "color": "#d7b8b0" }, { "id": "3-B1", "name": "3-B1", "color": "#48b46f" }, { "id": "3-B2", "name": "3-B2", "color": "#d8bf77" }, { "id": "3-B3", "name": "3-B3", "color": "#cf7a9e" }, { "id": "3-B4", "name": "3-B4", "color": "#d6c44b" }, { "id": "3-C1", "name": "3-C1", "color": "#cb83a2" }, { "id": "3-C2", "name": "3-C2", "color": "#4f8bbf" }, { "id": "3-C3", "name": "3-C3", "color": "#d6b09e" }, { "id": "3-C4", "name": "3-C4", "color": "#caa23b" }, { "id": "3-D1", "name": "3-D1", "color": "#d0c581" }, { "id": "3-D2", "name": "3-D2", "color": "#aeb5c9" }, { "id": "3-D3", "name": "3-D3", "color": "#de6a2a" }, { "id": "3-D4", "name": "3-D4", "color": "#49b06a" }, { "id": "3-E1", "name": "3-E1", "color": "#2e86c1" }, { "id": "3-E2", "name": "3-E2", "color": "#b37a52" }, { "id": "3-E3", "name": "3-E3", "color": "#cf2f5b" }, { "id": "3-E4", "name": "3-E4", "color": "#2a6f5d" }, { "id": "3-F1", "name": "3-F1", "color": "#8e1f2d" }, { "id": "3-F2", "name": "3-F2", "color": "#3d1a68" }, { "id": "3-F3", "name": "3-F3", "color": "#5d3c32" }, { "id": "3-F4", "name": "3-F4", "color": "#3a3a3a" }];

            // 48 cores básicas para "Novo projeto"
            function buildBasicPalette48() {
                // 48 = 6 colunas (A-F) x 8 linhas (1-8). nome em "0-A1" etc.
                const colors = [
                    "#000000", "#ffffff", "#9ca3af", "#6b7280", "#ef4444", "#b91c1c",
                    "#f97316", "#c2410c", "#f59e0b", "#b45309", "#eab308", "#a16207",
                    "#22c55e", "#15803d", "#10b981", "#047857", "#06b6d4", "#0e7490",
                    "#3b82f6", "#1d4ed8", "#6366f1", "#4338ca", "#8b5cf6", "#6d28d9",
                    "#ec4899", "#be185d", "#f43f5e", "#9f1239", "#a855f7", "#7e22ce",
                    "#14b8a6", "#0f766e", "#84cc16", "#4d7c0f", "#fb7185", "#9f1239",
                    "#38bdf8", "#0369a1", "#60a5fa", "#1e40af", "#fda4af", "#be123c",
                    "#c084fc", "#6d28d9", "#a3e635", "#3f6212", "#fcd34d", "#b45309"
                ].map(normalizeHex);

                const letters = ["A", "B", "C", "D", "E", "F"];
                const palette = [];
                let i = 0;
                for (let row = 1; row <= 8; row++) {
                    for (let col = 0; col < 6; col++) {
                        const name = `0-${letters[col]}${row}`;
                        palette.push({ id: uid(), name, color: colors[i++] || "#ffffff" });
                    }
                }
                return palette;
            }

            // ===== Estado =====
            const state = {
                docName: "Sem título",
                paletteName: "Paleta completa",
                rows: 29,
                cols: 29,
                cellSize: 18,
                viewMode: "round",
                tool: "paint",
                mirror: false,
                palette: [],
                selectedColorId: null,
                grid: [],
                dirty: false,
                selection: {
                    active: false,
                    type: null, // "rect" | "lasso"
                    points: [],
                    rect: null, // { r1, c1, r2, c2 }
                    floating: null, // Array of { r, c, hex }
                    isMoving: false,
                    startMove: null
                },
                shapes: {
                    active: false,
                    start: null,
                    current: null,
                    points: []
                },
                fillShapes: true
            };

            const history = {
                undoStack: [],
                redoStack: []
            };

            function pushHistory() {
                history.undoStack.push([...state.grid]);
                history.redoStack = [];
                if (history.undoStack.length > 200) history.undoStack.shift();
            }

            function undo() {
                if (history.undoStack.length === 0) return;
                history.redoStack.push([...state.grid]);
                state.grid = history.undoStack.pop();
                state.dirty = true;
                renderBoard();
                renderUsedPanel();
                updateStatus();
                autosave();
            }

            function redo() {
                if (history.redoStack.length === 0) return;
                history.undoStack.push([...state.grid]);
                state.grid = history.redoStack.pop();
                state.dirty = true;
                renderBoard();
                renderUsedPanel();
                updateStatus();
                autosave();
            }

            const LS_KEY = "hama_designer_autosave_v12";

            function paletteDisplayName(p) {
                const raw = String(p?.name ?? p?.id ?? "").trim();
                const m = raw.match(/^(\d+)-([A-Z])(\d+)$/i);
                if (!m) return raw;
                const img = m[1];
                const oldRowLetter = m[2].toUpperCase();
                const oldColNum = parseInt(m[3], 10);
                if (!(oldColNum >= 1 && oldColNum <= 26)) return raw;
                const rowNumber = oldRowLetter.charCodeAt(0) - 64;
                if (rowNumber < 1) return raw;
                const colLetter = String.fromCharCode(64 + oldColNum);
                return `${img}-${colLetter}${rowNumber}`;
            }

            function makeEmptyGrid(rows, cols) { return new Array(rows * cols).fill(""); }
            function idx(r, c) { return r * state.cols + c; }
            function inBounds(r, c) { return r >= 0 && c >= 0 && r < state.rows && c < state.cols; }
            function getCell(r, c) { return inBounds(r, c) ? (state.grid[idx(r, c)] || "") : ""; }
            function setCell(r, c, hex) { if (inBounds(r, c)) { state.grid[idx(r, c)] = hex || ""; state.dirty = true; } }

            // ===== Arquivos =====
            function serialize() {
                return {
                    app: "HamaBeadsDesigner",
                    version: 12,
                    savedAt: new Date().toISOString(),
                    docName: state.docName,
                    paletteName: state.paletteName,
                    rows: state.rows,
                    cols: state.cols,
                    cellSize: state.cellSize,
                    viewMode: state.viewMode,
                    palette: state.palette,               // salva paleta junto do projeto
                    selectedColorId: state.selectedColorId,
                    grid: state.grid
                };
            }

            function deserialize(obj) {
                if (!obj || obj.app !== "HamaBeadsDesigner") throw new Error("Arquivo inválido (app).");
                state.docName = String(obj.docName || "Sem título");
                state.paletteName = String(obj.paletteName || "Paleta (sem nome)");
                state.rows = clampInt(obj.rows, 1, 400);
                state.cols = clampInt(obj.cols, 1, 400);
                state.cellSize = clampInt(obj.cellSize ?? 18, 6, 42);
                state.viewMode = (obj.viewMode === "pixel" || obj.viewMode === "melted" || obj.viewMode === "round") ? obj.viewMode : "round";
                state.tool = "paint";
                state.mirror = false;
                state.selection.active = false;
                state.selection.floating = null;
                state.selection.points = [];
                state.palette = Array.isArray(obj.palette) ? obj.palette : [];
                // se abriu arquivo antigo sem paleta, cair na completa
                if (!state.palette.length) {
                    state.paletteName = "Paleta completa";
                    state.palette = FULL_PALETTE.map(p => ({ id: uid(), name: p.name, color: normalizeHex(p.color) || "#ffffff" }));
                }
                state.selectedColorId = obj.selectedColorId ?? (state.palette[0]?.id ?? null);
                state.grid = Array.isArray(obj.grid) ? obj.grid.slice(0, state.rows * state.cols) : makeEmptyGrid(state.rows, state.cols);
                if (state.grid.length < state.rows * state.cols) {
                    state.grid = state.grid.concat(new Array(state.rows * state.cols - state.grid.length).fill(""));
                }
                state.dirty = false;
            }

            function serializePalette(paletteName) {
                return {
                    app: "HamaBeadsPalette",
                    version: 1,
                    savedAt: new Date().toISOString(),
                    paletteName: String(paletteName || "Paleta (sem nome)"),
                    palette: state.palette
                };
            }

            function deserializePalette(obj) {
                if (!obj || obj.app !== "HamaBeadsPalette") throw new Error("Arquivo de paleta inválido.");
                const pal = Array.isArray(obj.palette) ? obj.palette : [];
                if (!pal.length) throw new Error("Paleta vazia.");
                // normaliza ids ausentes
                const fixed = pal.map(p => ({
                    id: p.id || uid(),
                    name: String(p.name || p.id || "").trim() || ("cor-" + uid().slice(0, 6)),
                    color: normalizeHex(p.color) || "#ffffff"
                }));
                state.paletteName = String(obj.paletteName || "Paleta (sem nome)");
                state.palette = fixed;
                state.selectedColorId = state.palette[0]?.id ?? null;
                state.dirty = true;
            }

            function autosave() { try { localStorage.setItem(LS_KEY, JSON.stringify(serialize())); } catch { } }
            function tryAutoload() {
                try {
                    const s = localStorage.getItem(LS_KEY);
                    if (!s) return false;
                    deserialize(JSON.parse(s));
                    return true;
                } catch { return false; }
            }

            function downloadText(filename, text) {
                const blob = new Blob([text], { type: "application/json" });
                const a = document.createElement("a");
                a.href = URL.createObjectURL(blob);
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                setTimeout(() => { URL.revokeObjectURL(a.href); a.remove(); }, 0);
            }

            function askSaveNameAndSave() {
                const current = sanitizeFileBaseName(state.docName);
                const suggested = current.endsWith(".hama.json") ? current : (current + ".hama.json");
                const typed = prompt("Nome do arquivo para salvar:", suggested);
                if (typed === null) return;

                let filename = sanitizeFileBaseName(typed);
                if (!filename.toLowerCase().endsWith(".json")) filename += ".hama.json";

                const base = filename.replace(/\.hama\.json$/i, "").replace(/\.json$/i, "");
                state.docName = base || "Sem título";

                const data = JSON.stringify(serialize(), null, 2);
                downloadText(filename, data);
                state.dirty = false;
                updateDocInfo();
                autosave();
            }

            function askSavePalette() {
                const baseDoc = sanitizeFileBaseName(state.docName);
                const current = sanitizeFileBaseName(state.paletteName || "paleta");
                const suggested = `${current || "paleta"}-${baseDoc || "projeto"}.palette.json`;
                const typed = prompt("Nome do arquivo da paleta:", suggested);
                if (typed === null) return;

                let filename = sanitizeFileBaseName(typed);
                if (!filename.toLowerCase().endsWith(".json")) filename += ".palette.json";
                if (!filename.toLowerCase().includes(".palette")) filename = filename.replace(/\.json$/i, ".palette.json");

                const palName = prompt("Nome da paleta (aparece no projeto):", state.paletteName || "Paleta (sem nome)");
                if (palName === null) return;
                state.paletteName = String(palName || "Paleta (sem nome)");

                const data = JSON.stringify(serializePalette(state.paletteName), null, 2);
                downloadText(filename, data);
                updateDocInfo();
                autosave();
            }

            // ===== UI =====
            const el = {
                board: document.getElementById("board"),
                wrap: document.getElementById("canvasWrap"),
                overlay: document.getElementById("loadingOverlay"),
                overlayName: document.getElementById("loadingFileName"),

                replaceSwatches: document.getElementById("replaceSwatches"),

                convertBeadsPreviewCanvas: document.getElementById("convertBeadsPreviewCanvas"),
                convertPreviewCellSize: document.getElementById("convertPreviewCellSize"),
                convertPreviewCellSizeLbl: document.getElementById("convertPreviewCellSizeLbl"),
                convertPreviewMode: document.getElementById("convertPreviewMode"),

                viewMode: document.getElementById("viewMode"),
                cellSize: document.getElementById("cellSize"),
                cellSizeLabel: document.getElementById("cellSizeLabel"),
                chkMirror: document.getElementById("chkMirror"),
                swatches: document.getElementById("swatches"),
                palSearch: document.getElementById("palSearch"),
                docInfo: document.getElementById("docInfo"),
                statusLeft: document.getElementById("statusLeft"),
                statusRight: document.getElementById("statusRight"),

                btnNewProject: document.getElementById("btnNewProject"),
                btnResize: document.getElementById("btnResize"),
                btnClear: document.getElementById("btnClear"),
                btnSave: document.getElementById("btnSave"),
                btnOpen: document.getElementById("btnOpen"),
                fileOpen: document.getElementById("fileOpen"),
                btnExportPng: document.getElementById("btnExportPng"),
                btnResetView: document.getElementById("btnResetView"),
                // btnAddColor: document.getElementById("btnAddColor"), // Removed from left sidebar, now handled by class
                btnManageColors: document.getElementById("btnManageColors"),
                btnHelp: document.getElementById("btnHelp"),

                btnSavePalette: document.getElementById("btnSavePalette"),
                btnLoadPalette: document.getElementById("btnLoadPalette"),
                fileOpenPalette: document.getElementById("fileOpenPalette"),

                btnDeleteAllColors: document.getElementById("btnDeleteAllColors"),

                dlgResize: document.getElementById("dlgResize"),
                resizeRows: document.getElementById("resizeRows"),
                resizeCols: document.getElementById("resizeCols"),
                resizeKeep: document.getElementById("resizeKeep"),
                dlgResizeApply: document.getElementById("dlgResizeApply"),
                dlgResizeClose: document.getElementById("dlgResizeClose"),

                dlgColor: document.getElementById("dlgColor"),
                dlgColorTitle: document.getElementById("dlgColorTitle"),
                dlgColorClose: document.getElementById("dlgColorClose"),
                colorName: document.getElementById("colorName"),
                colorHex: document.getElementById("colorHex"),
                dlgColorSave: document.getElementById("dlgColorSave"),
                dlgColorDelete: document.getElementById("dlgColorDelete"),

                dlgManage: document.getElementById("dlgManage"),
                manageSwatches: document.getElementById("manageSwatches"),
                dlgManageClose: document.getElementById("dlgManageClose"),
                dlgManageDone: document.getElementById("dlgManageDone"),

                btnLoadManageImg: document.getElementById("btnLoadManageImg"),
                manageImgFile: document.getElementById("manageImgFile"),
                manageImgCanvas: document.getElementById("manageImgCanvas"),
                manageImgZoom: document.getElementById("manageImgZoom"),
                manageImgZoomLbl: document.getElementById("manageImgZoomLbl"),
                btnManageResetView: document.getElementById("btnManageResetView"),
                manageSampleDot: document.getElementById("manageSampleDot"),
                manageSampleHex: document.getElementById("manageSampleHex"),
                manageSampleNote: document.getElementById("manageSampleNote"),
                manageSampleColor: document.getElementById("manageSampleColor"),
                manageNewColorName: document.getElementById("manageNewColorName"),
                btnAddFromSample: document.getElementById("btnAddFromSample"),

                dlgHelp: document.getElementById("dlgHelp"),
                dlgHelpClose: document.getElementById("dlgHelpClose"),
                dlgHelpOk: document.getElementById("dlgHelpOk"),

                rightToggle: document.getElementById("rightToggle"),
                rightChev: document.getElementById("rightChev"),
                usedList: document.getElementById("usedList"),
                usedTotal: document.getElementById("usedTotal"),
                usedUnique: document.getElementById("usedUnique"),

                dlgReplace: document.getElementById("dlgReplace"),
                dlgReplaceClose: document.getElementById("dlgReplaceClose"),
                dlgReplaceApply: document.getElementById("dlgReplaceApply"),
                replaceFromText: document.getElementById("replaceFromText"),
                replaceToSelect: document.getElementById("replaceToSelect"),

                // imagem -> beads
                btnImgToBeads: document.getElementById("btnImgToBeads"),
                dlgImgToBeads: document.getElementById("dlgImgToBeads"),
                dlgImgToBeadsClose: document.getElementById("dlgImgToBeadsClose"),
                dlgImgToBeadsDone: document.getElementById("dlgImgToBeadsDone"),

                btnLoadConvertImg: document.getElementById("btnLoadConvertImg"),
                convertImgFile: document.getElementById("convertImgFile"),
                convertImgCanvas: document.getElementById("convertImgCanvas"),
                btnConvertResetView: document.getElementById("btnConvertResetView"),
                convertImgZoom: document.getElementById("convertImgZoom"),
                convertImgZoomLbl: document.getElementById("convertImgZoomLbl"),
                convertStats: document.getElementById("convertStats"),

                convertColorMode: document.getElementById("convertColorMode"),
                convertMaxSide: document.getElementById("convertMaxSide"),
                convertLockAspect: document.getElementById("convertLockAspect"),
                convertCols: document.getElementById("convertCols"),
                convertRows: document.getElementById("convertRows"),
                convertK: document.getElementById("convertK"),
                convertIters: document.getElementById("convertIters"),
                convertDither: document.getElementById("convertDither"),
                convertReplacePalette: document.getElementById("convertReplacePalette"),
                convertAutoApply: document.getElementById("convertAutoApply"),
                btnConvertPreview: document.getElementById("btnConvertPreview"),
                btnConvertApply: document.getElementById("btnConvertApply"),
                dlgReplaceDelete: document.getElementById("dlgReplaceDelete"),

                footerControls: document.querySelector(".footerControls"),
                toolButtons: document.querySelectorAll(".tool-button"),
                chkFill: document.getElementById("chkFill"),
                btnUndo: document.getElementById("btnUndo"),
                btnRedo: document.getElementById("btnRedo"),
            };

            const ctx = el.board.getContext("2d");

            function showLoading(fileName) {
                el.overlayName.textContent = fileName || "Aguarde";
                el.overlay.classList.add("show");
            }
            function hideLoading() { el.overlay.classList.remove("show"); }

            function closeDialog(dlg) { try { dlg.close(); } catch { } }

            function getSelectedColor() {
                const c = state.palette.find(x => x.id === state.selectedColorId);
                return c ? c.color : "#ffffff";
            }
            function setSelectedColorByHex(hex) {
                hex = normalizeHex(hex);
                if (!hex) return;
                const found = state.palette.find(x => normalizeHex(x.color) === hex);
                if (found) {
                    state.selectedColorId = found.id;
                    renderPalette();
                    updateStatus();
                }
            }

            // ===== Render board =====
            function drawRoundedRect(ctx2, x, y, w, h, r) {
                const rr = Math.min(r, w / 2, h / 2);
                ctx2.beginPath();
                ctx2.moveTo(x + rr, y);
                ctx2.arcTo(x + w, y, x + w, y + h, rr);
                ctx2.arcTo(x + w, y + h, x, y + h, rr);
                ctx2.arcTo(x, y + h, x, y, rr);
                ctx2.arcTo(x, y, x + w, y, rr);
                ctx2.closePath();
            }

            function renderGridLines(ctx2, cs, w, h, forExport) {
                ctx2.strokeStyle = forExport ? "rgba(160,160,160,.45)" : "rgba(255,255,255,.06)";
                ctx2.lineWidth = 1;
                ctx2.beginPath();
                for (let c = 0; c <= state.cols; c++) {
                    const x = c * cs + 0.5;
                    ctx2.moveTo(x, 0); ctx2.lineTo(x, h);
                }
                for (let r = 0; r <= state.rows; r++) {
                    const y = r * cs + 0.5;
                    ctx2.moveTo(0, y); ctx2.lineTo(w, y);
                }
                ctx2.stroke();
            }

            function renderTo(ctx2, w, h, { forExport = false } = {}) {
                const cs = state.cellSize;
                ctx2.clearRect(0, 0, w, h);

                if (!forExport) {
                    ctx2.fillStyle = "rgba(255,255,255,.03)";
                    ctx2.fillRect(0, 0, w, h);
                }

                renderGridLines(ctx2, cs, w, h, forExport);

                const mode = state.viewMode;

                for (let r = 0; r < state.rows; r++) {
                    for (let c = 0; c < state.cols; c++) {
                        const hex = getCell(r, c);
                        if (!hex) continue;

                        const x = c * cs, y = r * cs;

                        if (mode === "pixel") {
                            ctx2.fillStyle = hex;
                            ctx2.fillRect(x + 1, y + 1, cs - 2, cs - 2);
                            continue;
                        }

                        if (mode === "round") {
                            const pad = Math.max(1, Math.floor(cs * 0.04));
                            const cx = x + cs / 2, cy = y + cs / 2;
                            const rad = (cs / 2) - pad;

                            ctx2.beginPath();
                            ctx2.arc(cx, cy, rad, 0, Math.PI * 2);
                            ctx2.fillStyle = hex;
                            ctx2.fill();

                            ctx2.save();
                            ctx2.beginPath();
                            ctx2.arc(cx, cy, rad * 0.35, 0, Math.PI * 2);
                            if (forExport) {
                                ctx2.globalCompositeOperation = "destination-out";
                                ctx2.fill();
                            } else {
                                ctx2.fillStyle = "#0b1224";
                                ctx2.fill();
                            }
                            ctx2.restore();
                            continue;
                        }

                        const radius = Math.max(2, cs * 0.22);
                        ctx2.save();
                        ctx2.fillStyle = hex;
                        drawRoundedRect(ctx2, x, y, cs, cs, radius);
                        ctx2.fill();

                        ctx2.globalAlpha = 0.10;
                        ctx2.fillStyle = "#ffffff";
                        drawRoundedRect(ctx2, x + cs * 0.10, y + cs * 0.10, cs * 0.55, cs * 0.28, Math.max(2, cs * 0.18));
                        ctx2.fill();
                        ctx2.restore();
                    }
                }

                // Render floating selection
                if (state.selection.active && state.selection.floating) {
                    const ox = state.selection.ox || 0;
                    const oy = state.selection.oy || 0;
                    for (const p of state.selection.floating) {
                        const r = p.r + oy;
                        const c = p.c + ox;
                        if (!inBounds(r, c)) continue;
                        const x = c * cs, y = r * cs;
                        ctx2.globalAlpha = 1.0;
                        if (mode === "pixel") {
                            ctx2.fillStyle = p.hex;
                            ctx2.fillRect(x + 1, y + 1, cs - 2, cs - 2);
                        } else if (mode === "round") {
                            const cx = x + cs / 2, cy = y + cs / 2, rad = (cs / 2) - Math.max(1, Math.floor(cs * 0.04));
                            ctx2.beginPath(); ctx2.arc(cx, cy, rad, 0, Math.PI * 2);
                            ctx2.fillStyle = p.hex; ctx2.fill();
                            ctx2.fillStyle = "#0b1224"; ctx2.beginPath(); ctx2.arc(cx, cy, rad * 0.35, 0, Math.PI * 2); ctx2.fill();
                        } else {
                            ctx2.fillStyle = p.hex; drawRoundedRect(ctx2, x, y, cs, cs, Math.max(2, cs * 0.22)); ctx2.fill();
                        }
                    }
                }

                // Selection outline
                if (state.selection.active || state.selection.points.length > 0) {
                    ctx2.save();
                    ctx2.strokeStyle = "#ffffff";
                    ctx2.lineWidth = 2;
                    ctx2.setLineDash([5, 5]);
                    ctx2.lineDashOffset = (Date.now() / 100) % 10;

                    if (state.selection.type === "rect" && state.selection.rect) {
                        const { r1, c1, r2, c2 } = state.selection.rect;
                        const x = Math.min(c1, c2) * cs + (state.selection.ox || 0) * cs;
                        const y = Math.min(r1, r2) * cs + (state.selection.oy || 0) * cs;
                        const w2 = (Math.abs(c2 - c1) + 1) * cs;
                        const h2 = (Math.abs(r2 - r1) + 1) * cs;
                        ctx2.strokeRect(x, y, w2, h2);
                    } else if (state.selection.points.length > 1) {
                        ctx2.beginPath();
                        const s_ox = (state.selection.ox || 0) * cs;
                        const s_oy = (state.selection.oy || 0) * cs;
                        for (let i = 0; i < state.selection.points.length; i++) {
                            const p = state.selection.points[i];
                            const px = p.c * cs + s_ox + cs / 2;
                            const py = p.r * cs + s_oy + cs / 2;
                            if (i === 0) ctx2.moveTo(px, py);
                            else ctx2.lineTo(px, py);
                        }
                        if (state.selection.active) ctx2.closePath();
                        ctx2.stroke();
                    }
                    ctx2.restore();
                    if (state.selection.points.length > 0) {
                        // Request next frame for animated dash
                        requestAnimationFrame(() => renderBoard());
                    }
                }

                // Preview de Formas (Linha, Retângulo, Elipse, Polígono)
                if (["line", "rect", "ellipse", "polygon"].includes(state.tool)) {
                    const hex = getSelectedColor();
                    let pts = [];
                    if (state.tool === "polygon") {
                        if (state.shapes.points.length > 0) {
                            ctx2.save();
                            ctx2.strokeStyle = hex;
                            ctx2.setLineDash([5, 5]);
                            ctx2.beginPath();
                            for (let i = 0; i < state.shapes.points.length; i++) {
                                const px = state.shapes.points[i].c * cs + cs / 2;
                                const py = state.shapes.points[i].r * cs + cs / 2;
                                if (i === 0) ctx2.moveTo(px, py); else ctx2.lineTo(px, py);
                            }
                            if (state.shapes.current) {
                                ctx2.lineTo(state.shapes.current.c * cs + cs / 2, state.shapes.current.r * cs + cs / 2);
                            }
                            ctx2.stroke();
                            ctx2.restore();
                        }
                    } else if (state.shapes.start && state.shapes.current) {
                        if (state.tool === "line") pts = getLinePoints(state.shapes.start.r, state.shapes.start.c, state.shapes.current.r, state.shapes.current.c);
                        else if (state.tool === "rect") pts = getRectPoints(state.shapes.start.r, state.shapes.start.c, state.shapes.current.r, state.shapes.current.c);
                        else if (state.tool === "ellipse") pts = getEllipsePoints(state.shapes.start.r, state.shapes.start.c, state.shapes.current.r, state.shapes.current.c);

                        ctx2.save();
                        ctx2.globalAlpha = 0.5;
                        ctx2.fillStyle = hex;
                        for (const p of pts) {
                            if (inBounds(p.r, p.c)) ctx2.fillRect(p.c * cs, p.r * cs, cs, cs);
                        }
                        ctx2.restore();
                    }
                }
            }

            function isPointInPoly(poly, r, c) {
                let inside = false;
                for (let i = 0, j = poly.length - 1; i < poly.length; j = i++) {
                    const xi = poly[i].c, yi = poly[i].r;
                    const xj = poly[j].c, yj = poly[j].r;
                    const intersect = ((yi > r) !== (yj > r)) && (c < (xj - xi) * (r - yi) / (yj - yi) + xi);
                    if (intersect) inside = !inside;
                }
                return inside;
            }

            function commitSelection() {
                if (!state.selection.active || !state.selection.floating) return;
                const ox = state.selection.ox || 0;
                const oy = state.selection.oy || 0;
                for (const p of state.selection.floating) {
                    const nr = p.r + oy, nc = p.c + ox;
                    if (inBounds(nr, nc)) setCell(nr, nc, p.hex);
                }
                state.selection.active = false;
                state.selection.floating = null;
                state.selection.points = [];
                state.selection.rect = null;
                state.selection.ox = 0;
                state.selection.oy = 0;
                state.dirty = true;
                autosave();
            }

            // --- Shape Utilities ---
            function getLinePoints(r1, c1, r2, c2) {
                const points = [];
                let dr = Math.abs(r2 - r1), dc = Math.abs(c2 - c1);
                let sr = (r1 < r2) ? 1 : -1, sc = (c1 < c2) ? 1 : -1;
                let err = (dc > dr ? dc : -dr) / 2;
                let r = r1, c = c1;
                while (true) {
                    points.push({ r, c });
                    if (r === r2 && c === c2) break;
                    let e2 = err;
                    if (e2 > -dc) { err -= dr; c += sc; }
                    if (e2 < dr) { err += dc; r += sr; }
                }
                return points;
            }

            function getRectPoints(r1, c1, r2, c2) {
                const points = [];
                const minR = Math.min(r1, r2), maxR = Math.max(r1, r2);
                const minC = Math.min(c1, c2), maxC = Math.max(c1, c2);
                for (let r = minR; r <= maxR; r++) {
                    for (let c = minC; c <= maxC; c++) {
                        if (state.fillShapes || r === minR || r === maxR || c === minC || c === maxC) {
                            points.push({ r, c });
                        }
                    }
                }
                return points;
            }

            function getEllipsePoints(r1, c1, r2, c2) {
                const points = [];
                const minR = Math.min(r1, r2), maxR = Math.max(r1, r2);
                const minC = Math.min(c1, c2), maxC = Math.max(c1, c2);
                const xc = (minC + maxC) / 2, yc = (minR + maxR) / 2;
                const rx = (maxC - minC) / 2, ry = (maxR - minR) / 2;
                if (rx <= 0 || ry <= 0) {
                    return getLinePoints(minR, minC, maxR, maxC);
                }

                for (let r = minR; r <= maxR; r++) {
                    for (let c = minC; c <= maxC; c++) {
                        const dx = (c - xc) / rx;
                        const dy = (r - yc) / ry;
                        const distSq = dx * dx + dy * dy;
                        if (state.fillShapes) {
                            if (distSq <= 1.05) points.push({ r, c });
                        } else {
                            if (distSq <= 1.1 && distSq >= 0.7) {
                                let isEdge = false;
                                for (let [dr, dc] of [[0, 1], [0, -1], [1, 0], [-1, 0]]) {
                                    const dnx = (c + dc - xc) / rx, dny = (r + dr - yc) / ry;
                                    if (dnx * dnx + dny * dny > 1.05) { isEdge = true; break; }
                                }
                                if (isEdge) points.push({ r, c });
                            }
                        }
                    }
                }
                return points;
            }

            function getPolygonPoints(poly) {
                if (poly.length < 2) return [];
                if (!state.fillShapes || poly.length < 3) {
                    const points = [];
                    for (let i = 0; i < poly.length; i++) {
                        const p1 = poly[i];
                        const p2 = poly[(i + 1) % poly.length];
                        points.push(...getLinePoints(p1.r, p1.c, p2.r, p2.c));
                    }
                    return points;
                }
                const points = [];
                let minR = Infinity, maxR = -Infinity, minC = Infinity, maxC = -Infinity;
                for (const p of poly) {
                    minR = Math.min(minR, p.r); maxR = Math.max(maxR, p.r);
                    minC = Math.min(minC, p.c); maxC = Math.max(minC, p.c);
                }
                for (let r = minR; r <= maxR; r++) {
                    for (let c = minC; c <= maxC; c++) {
                        if (isPointInPoly(poly, r, c)) points.push({ r, c });
                    }
                }
                return points;
            }

            function drawShapePreview(ctx2) {
                const { type, start, current, points } = state.shapes;
                const hex = getSelectedColor();
                const cs = state.cellSize;
                let previewPoints = [];

                if (state.tool === "polygon") {
                    if (points.length > 0) {
                        ctx2.save();
                        ctx2.strokeStyle = hex;
                        ctx2.lineWidth = 2;
                        ctx2.beginPath();
                        for (let i = 0; i < points.length; i++) {
                            const x = points[i].c * cs + cs / 2;
                            const y = points[i].r * cs + cs / 2;
                            if (i === 0) ctx2.moveTo(x, y); else ctx2.lineTo(x, y);
                        }
                        if (current) {
                            ctx2.lineTo(current.c * cs + cs / 2, current.r * cs + cs / 2);
                        }
                        ctx2.stroke();
                        ctx2.restore();
                    }
                    return;
                }

                if (!start || !current) return;

                if (state.tool === "line") previewPoints = getLinePoints(start.r, start.c, current.r, current.c);
                else if (state.tool === "rect") previewPoints = getRectPoints(start.r, start.c, current.r, current.c);
                else if (state.tool === "ellipse") previewPoints = getEllipsePoints(start.r, start.c, current.r, current.c);

                ctx2.save();
                ctx2.globalAlpha = 0.5;
                ctx2.fillStyle = hex;
                for (const p of previewPoints) {
                    ctx2.fillRect(p.c * cs, p.r * cs, cs, cs);
                }
                ctx2.restore();
            }

            function rotate90() {
                pushHistory();
                if (state.selection.active && state.selection.floating) {
                    const f = state.selection.floating;
                    let minR, maxR, minC, maxC;

                    if (state.selection.type === "rect") {
                        const r = state.selection.rect;
                        minR = Math.min(r.r1, r.r2); maxR = Math.max(r.r1, r.r2);
                        minC = Math.min(r.c1, r.c2); maxC = Math.max(r.c1, r.c2);
                    } else {
                        minR = Infinity; maxR = -Infinity; minC = Infinity; maxC = -Infinity;
                        for (const p of state.selection.points) {
                            minR = Math.min(minR, p.r); maxR = Math.max(maxR, p.r);
                            minC = Math.min(minC, p.c); maxC = Math.max(minC, p.c);
                        }
                    }

                    const hSel = maxR - minR + 1;
                    const wSel = maxC - minC + 1;

                    for (const p of f) {
                        const dr = p.r - minR, dc = p.c - minC;
                        p.r = minR + dc;
                        p.c = minC + (hSel - 1 - dr);
                    }

                    if (state.selection.type === "rect") {
                        state.selection.rect = { r1: minR, c1: minC, r2: minR + wSel - 1, c2: minC + hSel - 1 };
                    } else {
                        for (const p of state.selection.points) {
                            const dr = p.r - minR, dc = p.c - minC;
                            p.r = minR + dc;
                            p.c = minC + (hSel - 1 - dr);
                        }
                    }
                    state.dirty = true;
                    renderBoard();
                    return;
                }

                const newGrid = new Array(state.rows * state.cols).fill("");
                if (state.rows !== state.cols) {
                    alert("Girar 90° só é suportado em boards quadrados no momento.");
                    return;
                }
                const N = state.rows;
                for (let r = 0; r < N; r++) {
                    for (let c = 0; c < N; c++) {
                        newGrid[c * N + (N - 1 - r)] = state.grid[r * N + c];
                    }
                }
                state.grid = newGrid;
                state.dirty = true;
                renderBoard();
                autosave();
            }

            function flipHorizontal() {
                pushHistory();
                if (state.selection.active && state.selection.floating) {
                    let minC, maxC;
                    if (state.selection.type === "rect") {
                        const r = state.selection.rect;
                        minC = Math.min(r.c1, r.c2); maxC = Math.max(r.c1, r.c2);
                    } else {
                        minC = Infinity; maxC = -Infinity;
                        for (const p of state.selection.points) {
                            minC = Math.min(minC, p.c); maxC = Math.max(maxC, p.c);
                        }
                    }
                    const mid = minC + maxC;
                    for (const p of state.selection.floating) p.c = mid - p.c;
                    for (const p of state.selection.points) p.c = mid - p.c;
                    state.dirty = true;
                    renderBoard();
                    return;
                }
                const newGrid = [...state.grid];
                for (let r = 0; r < state.rows; r++) {
                    for (let c = 0; c < Math.floor(state.cols / 2); c++) {
                        const i1 = r * state.cols + c;
                        const i2 = r * state.cols + (state.cols - 1 - c);
                        const tmp = newGrid[i1];
                        newGrid[i1] = newGrid[i2];
                        newGrid[i2] = tmp;
                    }
                }
                state.grid = newGrid;
                state.dirty = true;
                renderBoard();
                autosave();
            }

            function flipVertical() {
                pushHistory();
                if (state.selection.active && state.selection.floating) {
                    let minR, maxR;
                    if (state.selection.type === "rect") {
                        const r = state.selection.rect;
                        minR = Math.min(r.r1, r.r2); maxR = Math.max(r.r1, r.r2);
                    } else {
                        minR = Infinity; maxR = -Infinity;
                        for (const p of state.selection.points) {
                            minR = Math.min(minR, p.r); maxR = Math.max(maxR, p.r);
                        }
                    }
                    const mid = minR + maxR;
                    for (const p of state.selection.floating) p.r = mid - p.r;
                    for (const p of state.selection.points) p.r = mid - p.r;
                    state.dirty = true;
                    renderBoard();
                    return;
                }
                const newGrid = [...state.grid];
                for (let c = 0; c < state.cols; c++) {
                    for (let r = 0; r < Math.floor(state.rows / 2); r++) {
                        const i1 = r * state.cols + c;
                        const i2 = (state.rows - 1 - r) * state.cols + c;
                        const tmp = newGrid[i1];
                        newGrid[i1] = newGrid[i2];
                        newGrid[i2] = tmp;
                    }
                }
                state.grid = newGrid;
                state.dirty = true;
                renderBoard();
                autosave();
            }

            function resizeCanvasToBoard() {
                const cs = state.cellSize;
                el.board.width = state.cols * cs;
                el.board.height = state.rows * cs;
                renderBoard();
                updateDocInfo();
            }

            function renderBoard() {
                renderTo(ctx, el.board.width, el.board.height, { forExport: false });
            }

            function canvasToCell(evt) {
                const rect = el.board.getBoundingClientRect();
                const x = evt.clientX - rect.left;
                const y = evt.clientY - rect.top;
                return { c: Math.floor(x / state.cellSize), r: Math.floor(y / state.cellSize) };
            }

            function floodFill(r, c, newHex) {
                const startHex = normalizeHex(getCell(r, c));
                const targetHex = normalizeHex(newHex);
                if (startHex === targetHex) return;

                const stack = [[r, c]];
                const cols = state.cols;
                while (stack.length > 0) {
                    const [currR, currC] = stack.pop();
                    if (!inBounds(currR, currC)) continue;
                    const i = currR * cols + currC;
                    if (normalizeHex(state.grid[i]) !== startHex) continue;

                    state.grid[i] = targetHex;
                    stack.push([currR + 1, currC], [currR - 1, currC], [currR, currC + 1], [currR, currC - 1]);
                }
                state.dirty = true;
            }

            function drawLine(r0, c0, r1, c1, hex) {
                let dx = Math.abs(c1 - c0), sx = c0 < c1 ? 1 : -1;
                let dy = -Math.abs(r1 - r0), sy = r0 < r1 ? 1 : -1;
                let err = dx + dy;
                let r = r0, c = c0;
                while (true) {
                    setCell(r, c, hex);
                    if (r === r1 && c === c1) break;
                    const e2 = 2 * err;
                    if (e2 >= dy) { err += dy; c += sx; }
                    if (e2 <= dx) { err += dx; r += sy; }
                }
            }

            // ===== Paleta =====
            function renderPalette() {
                const q = el.palSearch.value.trim().toLowerCase();
                el.swatches.innerHTML = "";
                const frag = document.createDocumentFragment();

                for (const p of state.palette) {
                    const disp = paletteDisplayName(p);
                    const hay = (disp + " " + (p.name ?? "") + " " + (p.id ?? "")).toLowerCase();
                    if (q && !hay.includes(q)) continue;

                    const btn = document.createElement("div");
                    btn.className = "swatch";
                    btn.style.setProperty("--c", p.color);
                    btn.setAttribute("role", "option");
                    btn.setAttribute("tabindex", "0");
                    btn.setAttribute("aria-selected", String(p.id === state.selectedColorId));
                    btn.title = `${disp}  (${p.color})`;

                    const chip = document.createElement("div");
                    chip.className = "chip";

                    const small = document.createElement("small");
                    small.textContent = disp;

                    btn.appendChild(chip);
                    btn.appendChild(small);

                    btn.addEventListener("click", () => {
                        state.selectedColorId = p.id;
                        renderPalette();
                        updateStatus();
                    });

                    frag.appendChild(btn);
                }
                el.swatches.appendChild(frag);
            }

            // ===== Used panel =====
            function computeUsage() {
                const counts = new Map();
                let total = 0;
                for (const v of state.grid) {
                    const hv = normalizeHex(v);
                    if (!hv) continue;
                    total++;
                    counts.set(hv, (counts.get(hv) || 0) + 1);
                }
                const items = Array.from(counts.entries()).map(([hex, count]) => ({ hex, count }));
                items.sort((a, b) => b.count - a.count);
                return { total, unique: items.length, items };
            }

            function paletteNameForHex(hex) {
                hex = normalizeHex(hex);
                const p = state.palette.find(x => normalizeHex(x.color) === hex);
                return p ? paletteDisplayName(p) : hex;
            }

            function renderUsedPanel() {
                const usage = computeUsage();
                el.usedTotal.textContent = `Total: ${usage.total}`;
                el.usedUnique.textContent = `Únicas: ${usage.unique}`;

                el.usedList.innerHTML = "";
                const frag = document.createDocumentFragment();

                for (const it of usage.items) {
                    const row = document.createElement("div");
                    row.className = "usedItem";

                    const chip = document.createElement("div");
                    chip.className = "chip";
                    chip.style.background = it.hex;
                    chip.title = "Selecionar esta cor";
                    chip.addEventListener("click", () => setSelectedColorByHex(it.hex));

                    const meta = document.createElement("div");
                    meta.className = "usedMeta";

                    const name = document.createElement("div");
                    name.className = "name";
                    name.textContent = paletteNameForHex(it.hex);
                    name.title = "Selecionar esta cor";
                    name.addEventListener("click", () => setSelectedColorByHex(it.hex));

                    const hex = document.createElement("div");
                    hex.className = "hex";
                    hex.textContent = it.hex;

                    meta.appendChild(name);
                    meta.appendChild(hex);

                    const actions = document.createElement("div");
                    actions.className = "usedActions";

                    const count = document.createElement("div");
                    count.className = "count";
                    count.textContent = it.count;

                    const btnRep = document.createElement("button");
                    btnRep.textContent = "Substituir";
                    btnRep.className = "primary";
                    btnRep.addEventListener("click", () => openReplaceDialog(it.hex));

                    actions.appendChild(count);
                    actions.appendChild(btnRep);

                    row.appendChild(chip);
                    row.appendChild(meta);
                    row.appendChild(actions);

                    frag.appendChild(row);
                }

                el.usedList.appendChild(frag);
            }

            // ===== Replace dialog =====
            let replaceFromHex = null;
            let replaceToHex = null;

            function buildReplacePalette() {
                el.replaceSwatches.innerHTML = "";
                replaceToHex = null;

                for (const p of state.palette) {
                    const disp = paletteDisplayName(p);

                    const sw = document.createElement("div");
                    sw.className = "swatch";
                    sw.style.setProperty("--c", p.color);
                    sw.title = `${disp} (${p.color})`;

                    const chip = document.createElement("div");
                    chip.className = "chip";

                    const small = document.createElement("small");
                    small.textContent = disp;

                    sw.appendChild(chip);
                    sw.appendChild(small);

                    sw.addEventListener("click", () => {
                        replaceToHex = normalizeHex(p.color);

                        // marca visualmente
                        [...el.replaceSwatches.children].forEach(x =>
                            x.setAttribute("aria-selected", "false")
                        );
                        sw.setAttribute("aria-selected", "true");
                    });

                    el.replaceSwatches.appendChild(sw);
                }
            }

            function openReplaceDialog(fromHex) {
                replaceFromHex = normalizeHex(fromHex);
                buildReplacePalette();

                el.replaceFromText.textContent =
                    `Substituir: ${paletteNameForHex(replaceFromHex)} (${replaceFromHex})`;

                el.dlgReplace.showModal();
            }


            function applyReplace(fromHex, toHex) {
                fromHex = normalizeHex(fromHex);
                if (!fromHex) return;

                // If toHex is empty, we are deleting the color from the grid.
                // Otherwise we normalize it.
                if (toHex !== "") {
                    toHex = normalizeHex(toHex);
                    if (!toHex || fromHex === toHex) return;
                }

                state.grid = state.grid.map(v => (normalizeHex(v) === fromHex ? toHex : v));
                state.dirty = true;

                renderBoard();
                renderUsedPanel();
                updateStatus();
                autosave();
            }

            // ===== Cores (Adicionar/Editar) =====
            let editingColorId = null;

            function addColor(name, hex) {
                name = String(name || "").trim();
                hex = normalizeHex(hex);
                if (!name) name = "cor-" + uid().slice(0, 6);
                if (!hex) hex = "#ffffff";
                const id = uid();
                state.palette.push({ id, name, color: hex });
                if (!state.selectedColorId) state.selectedColorId = id;
                return id;
            }

            function updateColor(id, name, hex) {
                const p = state.palette.find(x => x.id === id);
                if (!p) return;
                if (name !== null && name !== undefined) {
                    p.name = String(name || p.name || "").trim() || p.name;
                }
                const nhex = normalizeHex(hex);
                if (nhex) p.color = nhex;
            }

            function deleteColor(id) {
                const i = state.palette.findIndex(x => x.id === id);
                if (i < 0) return;
                const removed = state.palette.splice(i, 1)[0];

                if (state.selectedColorId === removed.id) state.selectedColorId = state.palette[0]?.id ?? null;
                const rhex = normalizeHex(removed.color);
                if (rhex) state.grid = state.grid.map(v => normalizeHex(v) === rhex ? "" : v);

                state.dirty = true;
            }

            function openColorDialog(colorId = null) {
                editingColorId = colorId;
                const isEdit = !!colorId;
                el.dlgColorTitle.textContent = isEdit ? "Editar cor" : "Adicionar cor";
                el.dlgColorDelete.style.display = isEdit ? "inline-flex" : "none";

                if (isEdit) {
                    const p = state.palette.find(x => x.id === colorId);
                    el.colorName.value = p?.name ?? "";
                    el.colorHex.value = normalizeHex(p?.color) || "#ffffff";
                } else {
                    el.colorName.value = "";
                    el.colorHex.value = "#ffffff";
                }
                el.dlgColor.showModal();
            }

            // ===== Novo projeto =====
            function hasAnyFilledCell() {
                for (const v of state.grid) if (normalizeHex(v)) return true;
                return false;
            }

            function newProject() {
                if (hasAnyFilledCell()) {
                    const shouldSave = confirm("Existe trabalho no grid. Deseja salvar antes de criar um novo projeto?");
                    if (shouldSave) askSaveNameAndSave();
                }

                state.docName = "Sem título";
                state.paletteName = "Básica (48)";
                state.rows = 29;
                state.cols = 29;
                state.viewMode = "round";
                state.tool = "paint";
                state.mirror = false;
                state.selection.active = false;
                state.selection.floating = null;
                state.selection.points = [];
                if (el.chkMirror) el.chkMirror.checked = false;
                state.cellSize = clampInt(el.cellSize.value || 18, 6, 42);

                state.palette = buildBasicPalette48();
                state.selectedColorId = state.palette[0]?.id ?? null;
                state.grid = makeEmptyGrid(state.rows, state.cols);

                state.dirty = true;
                el.viewMode.value = state.viewMode;

                renderPalette();
                resizeCanvasToBoard();
                renderUsedPanel();
                updateStatus();
                autosave();
            }

            // ===== Resize board =====
            function openResizeDialog() {
                el.resizeRows.value = state.rows;
                el.resizeCols.value = state.cols;
                el.resizeKeep.checked = true;
                el.dlgResize.showModal();
            }

            function applyResize(rows, cols, keep) {
                pushHistory();
                rows = clampInt(rows, 1, 400);
                cols = clampInt(cols, 1, 400);
                if (rows === state.rows && cols === state.cols) return;

                const oldRows = state.rows, oldCols = state.cols;
                const oldGrid = state.grid.slice();

                state.rows = rows;
                state.cols = cols;
                state.grid = makeEmptyGrid(rows, cols);

                if (keep) {
                    const rr = Math.min(rows, oldRows);
                    const cc = Math.min(cols, oldCols);
                    for (let r = 0; r < rr; r++) {
                        for (let c = 0; c < cc; c++) {
                            state.grid[r * cols + c] = oldGrid[r * oldCols + c] || "";
                        }
                    }
                }

                state.dirty = true;
                resizeCanvasToBoard();
                renderUsedPanel();
                updateStatus();
                autosave();
            }

            // ===== Export PNG =====
            function exportPngWithUsedList() {
                const boardW = el.board.width;
                const boardH = el.board.height;

                const usage = computeUsage();
                const items = usage.items;

                const pad = Math.max(16, Math.round(state.cellSize * 0.8));
                const gap = pad;

                const listWidth = 320;
                const rowH = 26;
                const headerH = 58;
                const listH = headerH + items.length * rowH + pad;

                const outW = boardW + gap + listWidth + pad;
                const outH = Math.max(boardH, listH) + pad * 2;

                const out = document.createElement("canvas");
                out.width = outW;
                out.height = outH;
                const octx = out.getContext("2d");

                octx.save();
                octx.translate(pad, pad);
                renderTo(octx, boardW, boardH, { forExport: true });
                octx.restore();

                const listX = pad + boardW + gap;
                const listY = pad;

                octx.save();
                octx.fillStyle = "rgba(15, 23, 42, 0.65)";
                octx.strokeStyle = "rgba(255,255,255,0.18)";
                octx.lineWidth = 1;
                drawRoundedRect(octx, listX, listY, listWidth, Math.min(outH - pad * 2, listH), 14);
                octx.fill();
                octx.stroke();

                octx.fillStyle = "rgba(255,255,255,0.92)";
                octx.font = "600 14px system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif";
                octx.fillText("Cores usadas", listX + 14, listY + 22);

                octx.fillStyle = "rgba(255,255,255,0.70)";
                octx.font = "12px system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif";
                octx.fillText(`Projeto: ${state.docName}`, listX + 14, listY + 40);
                octx.fillText(`Paleta: ${state.paletteName}`, listX + 14, listY + 56);

                let y = listY + headerH;
                octx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, \"Liberation Mono\", monospace";
                for (const it of items) {
                    octx.beginPath();
                    octx.arc(listX + 18, y + rowH / 2, 6, 0, Math.PI * 2);
                    octx.fillStyle = it.hex;
                    octx.fill();
                    octx.strokeStyle = "rgba(0,0,0,0.25)";
                    octx.stroke();

                    octx.fillStyle = "rgba(255,255,255,0.92)";
                    const name = paletteNameForHex(it.hex);
                    octx.fillText(name, listX + 34, y + 17);

                    octx.fillStyle = "rgba(255,255,255,0.78)";
                    const txt = String(it.count);
                    const tw = octx.measureText(txt).width;
                    octx.fillText(txt, listX + listWidth - 14 - tw, y + 17);

                    octx.strokeStyle = "rgba(255,255,255,0.10)";
                    octx.beginPath();
                    octx.moveTo(listX + 12, y + rowH);
                    octx.lineTo(listX + listWidth - 12, y + rowH);
                    octx.stroke();

                    y += rowH;
                    if (y > listY + listH - rowH) break;
                }
                octx.restore();

                const a = document.createElement("a");
                a.href = out.toDataURL("image/png");
                const base = sanitizeFileBaseName(state.docName);
                a.download = base + ".png";
                document.body.appendChild(a);
                a.click();
                a.remove();
            }

            // ===== Gerenciar cores (mantido do seu arquivo) =====
            let manageSelectedColorId = null;

            function renderManagePalette() {
                el.manageSwatches.innerHTML = "";
                const frag = document.createDocumentFragment();
                for (const p of state.palette) {
                    const disp = paletteDisplayName(p);
                    const btn = document.createElement("div");
                    btn.className = "swatch";
                    btn.style.setProperty("--c", p.color);
                    btn.title = "Clique para selecionar. Duplo clique para editar.";

                    const chip = document.createElement("div");
                    chip.className = "chip";
                    const small = document.createElement("small");
                    small.textContent = disp;

                    btn.appendChild(chip);
                    btn.appendChild(small);

                    const isSel = manageSelectedColorId && p.id === manageSelectedColorId;
                    if (isSel) btn.classList.add("manage-selected");

                    btn.addEventListener("click", () => {
                        manageSelectedColorId = p.id;
                        renderManagePalette();
                        el.manageSampleNote.textContent = `Selecionada: ${disp}. Clique na imagem para aplicar.`;
                    });

                    btn.addEventListener("dblclick", () => openColorDialog(p.id));

                    frag.appendChild(btn);
                }
                el.manageSwatches.appendChild(frag);
            }

            // imagem no gerenciar
            const mimg = {
                img: null,
                off: document.createElement("canvas"),
                offCtx: null,
                scale: 1,
                minScale: 0.1,
                maxScale: 6,
                ox: 0,
                oy: 0,
                isPanning: false,
                lastX: 0,
                lastY: 0,
                sampleHex: "#ffffff",
            };
            mimg.offCtx = mimg.off.getContext("2d", { willReadFrequently: true });
            const mctx = el.manageImgCanvas.getContext("2d", { willReadFrequently: true });

            function setManageSample(hex, note) {
                hex = normalizeHex(hex) || "#ffffff";
                mimg.sampleHex = hex;
                el.manageSampleHex.textContent = hex;
                el.manageSampleDot.style.setProperty("--c", hex);
                el.manageSampleColor.value = hex;
                if (note) el.manageSampleNote.textContent = note;
            }

            function manageCanvasResizeToWrap() {
                const wrap = el.manageImgCanvas.parentElement;
                const dpr = window.devicePixelRatio || 1;
                const w = Math.max(1, Math.floor(wrap.clientWidth * dpr));
                const h = Math.max(1, Math.floor(wrap.clientHeight * dpr));
                el.manageImgCanvas.width = w;
                el.manageImgCanvas.height = h;
                drawManageImage();
            }

            function drawManageImage() {
                const w = el.manageImgCanvas.width;
                const h = el.manageImgCanvas.height;
                mctx.clearRect(0, 0, w, h);

                mctx.save();
                mctx.fillStyle = "rgba(255,255,255,0.03)";
                mctx.fillRect(0, 0, w, h);

                mctx.strokeStyle = "rgba(255,255,255,0.06)";
                mctx.lineWidth = 1;
                const step = Math.max(20, Math.floor(24 * (window.devicePixelRatio || 1)));
                mctx.beginPath();
                for (let x = 0; x <= w; x += step) { mctx.moveTo(x + 0.5, 0); mctx.lineTo(x + 0.5, h); }
                for (let y = 0; y <= h; y += step) { mctx.moveTo(0, y + 0.5); mctx.lineTo(w, y + 0.5); }
                mctx.stroke();
                mctx.restore();

                if (!mimg.img) {
                    mctx.save();
                    mctx.fillStyle = "rgba(255,255,255,.65)";
                    mctx.font = `${Math.floor(12 * (window.devicePixelRatio || 1))}px system-ui, -apple-system, Segoe UI, Roboto, Arial`;
                    mctx.fillText("Nenhuma imagem carregada.", 14 * (window.devicePixelRatio || 1), 26 * (window.devicePixelRatio || 1));
                    mctx.fillStyle = "rgba(255,255,255,.50)";
                    mctx.fillText("Use “Carregar imagem”.", 14 * (window.devicePixelRatio || 1), 46 * (window.devicePixelRatio || 1));
                    mctx.restore();
                    return;
                }

                mctx.save();
                mctx.imageSmoothingEnabled = false;
                mctx.translate(mimg.ox, mimg.oy);
                mctx.scale(mimg.scale, mimg.scale);
                mctx.drawImage(mimg.img, 0, 0);
                mctx.restore();
            }

            function manageResetView() {
                if (!mimg.img) {
                    mimg.scale = 1; mimg.ox = 0; mimg.oy = 0;
                    el.manageImgZoom.value = 100;
                    el.manageImgZoomLbl.textContent = "100%";
                    drawManageImage();
                    return;
                }
                const w = el.manageImgCanvas.width;
                const h = el.manageImgCanvas.height;
                const iw = mimg.img.width;
                const ih = mimg.img.height;

                const fit = Math.min(w / iw, h / ih) * 0.95;
                mimg.scale = Math.max(mimg.minScale, Math.min(mimg.maxScale, fit));
                mimg.ox = (w - iw * mimg.scale) / 2;
                mimg.oy = (h - ih * mimg.scale) / 2;

                const pct = Math.round(mimg.scale * 100);
                el.manageImgZoom.value = clampInt(pct, 10, 600);
                el.manageImgZoomLbl.textContent = `${el.manageImgZoom.value}%`;
                drawManageImage();
            }

            function setManageZoomPercent(pct, anchorX = null, anchorY = null) {
                pct = clampInt(pct, 10, 600);
                const newScale = pct / 100;

                const w = el.manageImgCanvas.width;
                const h = el.manageImgCanvas.height;
                const ax = (anchorX == null) ? (w / 2) : anchorX;
                const ay = (anchorY == null) ? (h / 2) : anchorY;

                const ix = (ax - mimg.ox) / mimg.scale;
                const iy = (ay - mimg.oy) / mimg.scale;

                mimg.scale = Math.max(mimg.minScale, Math.min(mimg.maxScale, newScale));
                mimg.ox = ax - ix * mimg.scale;
                mimg.oy = ay - iy * mimg.scale;

                el.manageImgZoom.value = pct;
                el.manageImgZoomLbl.textContent = `${pct}%`;
                drawManageImage();
            }

            function manageCanvasEventToCanvasXY(evt) {
                const rect = el.manageImgCanvas.getBoundingClientRect();
                const dpr = window.devicePixelRatio || 1;
                const x = (evt.clientX - rect.left) * dpr;
                const y = (evt.clientY - rect.top) * dpr;
                return { x, y };
            }

            function sampleColorAtCanvasXY(x, y) {
                if (!mimg.img) return null;
                const ix = (x - mimg.ox) / mimg.scale;
                const iy = (y - mimg.oy) / mimg.scale;

                const px = Math.floor(ix);
                const py = Math.floor(iy);
                if (px < 0 || py < 0 || px >= mimg.img.width || py >= mimg.img.height) return null;

                const data = mimg.offCtx.getImageData(px, py, 1, 1).data;
                const r = data[0], g = data[1], b = data[2], a = data[3];
                if (a === 0) return null;
                const hex = "#" + [r, g, b].map(v => v.toString(16).padStart(2, "0")).join("");
                return hex;
            }

            function applySampleToSelectedColor(hex) {
                hex = normalizeHex(hex);
                if (!hex) return;

                setManageSample(hex, "Cor capturada e aplicada.");

                if (!manageSelectedColorId) {
                    el.manageSampleNote.textContent = "Selecione uma cor na lista (direita) para aplicar automaticamente.";
                    return;
                }

                updateColor(manageSelectedColorId, null, hex);

                state.dirty = true;
                renderPalette();
                renderManagePalette();
                renderBoard();
                renderUsedPanel();
                updateStatus();
                autosave();
            }

            function openManageDialog() {
                el.dlgManage.showModal();
                manageCanvasResizeToWrap();
                setManageSample(mimg.sampleHex || "#ffffff", "Selecione uma cor na lista e clique na imagem.");
                if (!manageSelectedColorId && state.palette[0]) manageSelectedColorId = state.palette[0].id;
                renderManagePalette();
                if (mimg.img) manageResetView();
            }



            // ===== Converter imagem -> beads =====
            const conv = {
                img: null,
                off: document.createElement("canvas"),
                offCtx: null,

                view: {
                    scale: 1,
                    minScale: 0.1,
                    maxScale: 6,
                    ox: 0,
                    oy: 0,
                    isPanning: false,
                    lastX: 0,
                    lastY: 0,
                },

                // último resultado convertido (para aplicar)
                last: null,
                debounceT: null
            };
            conv.offCtx = conv.off.getContext("2d", { willReadFrequently: true });
            const cctx = el.convertImgCanvas.getContext("2d", { willReadFrequently: true });

            function rgbToHex(r, g, b) {
                return "#" + [r, g, b].map(v => clampInt(v, 0, 255).toString(16).padStart(2, "0")).join("");
            }
            function hexToRgb(hex) {
                hex = normalizeHex(hex);
                if (!hex) return { r: 0, g: 0, b: 0 };
                return {
                    r: parseInt(hex.slice(1, 3), 16),
                    g: parseInt(hex.slice(3, 5), 16),
                    b: parseInt(hex.slice(5, 7), 16),
                };
            }
            function dist2RGB(a, b) {
                const dr = a.r - b.r, dg = a.g - b.g, db = a.b - b.b;
                return dr * dr + dg * dg + db * db;
            }

            function convCanvasResizeToWrap() {
                // Resize Source Canvas
                const wrap = el.convertImgCanvas.parentElement;
                const dpr = window.devicePixelRatio || 1;
                const w = Math.max(1, Math.floor(wrap.clientWidth * dpr));
                const h = Math.max(1, Math.floor(wrap.clientHeight * dpr));
                el.convertImgCanvas.width = w;
                el.convertImgCanvas.height = h;

                // Resize Beads Preview Canvas
                // Ideally this canvas size depends on the beads content, but if we want it to fit the container...
                // Actually beads preview renders at specific size (cols*cellSize).
                // But the helper `renderBeadsPreview` sets width/height.
                // We just need to make sure the container allows scrolling if needed.
                // The container is .convertCanvasWrap with overflow:hidden in CSS, wait.
                // The new CSS has: .convertSource, .convertDest { grid-template-rows: auto 1fr auto; }
                // .convertCanvasWrap { overflow:hidden; } -- this might clip.
                // We want the beads preview to be scrollable if it's large?
                // Text says "Zoom preview" for beads.
                // The user said: "grid de beads melt na direita-superior".
                // Let's assume the preview canvas size is determined by grid size * zoom,
                // and we should let the parent handle overflow if we want scrolling, OR
                // we implement Pan/Zoom like logic for the preview too.
                // For now, let's just make sure we actally get the correct size.
                // The `renderBeadsPreview` sets canvas.width/height.
                // We don't need to force resize it here unless we implement custom Pan/Zoom logic for it.
                // Currently `convertImgCanvas` has Pan/Zoom logic.
                // The user requested Pan/Zoom for beads preview too? "Zoom preview" slider exists.
                // "Use roda do mouse para zoom, clique direito para arrastar" hint is on Left (Source).

                // For the Source Image, we need to redraw.
                drawConvertPreview();
                if (conv.img) convResetView();
            }

            function drawConvertPreview() {
                const w = el.convertImgCanvas.width;
                const h = el.convertImgCanvas.height;
                cctx.clearRect(0, 0, w, h);

                cctx.save();
                cctx.fillStyle = "rgba(255,255,255,0.03)";
                cctx.fillRect(0, 0, w, h);

                cctx.strokeStyle = "rgba(255,255,255,0.06)";
                cctx.lineWidth = 1;
                const step = Math.max(20, Math.floor(24 * (window.devicePixelRatio || 1)));
                cctx.beginPath();
                for (let x = 0; x <= w; x += step) { cctx.moveTo(x + 0.5, 0); cctx.lineTo(x + 0.5, h); }
                for (let y = 0; y <= h; y += step) { cctx.moveTo(0, y + 0.5); cctx.lineTo(w, y + 0.5); }
                cctx.stroke();
                cctx.restore();

                if (!conv.img) {
                    cctx.save();
                    cctx.fillStyle = "rgba(255,255,255,.65)";
                    cctx.font = `${Math.floor(12 * (window.devicePixelRatio || 1))}px system-ui, -apple-system, Segoe UI, Roboto, Arial`;
                    cctx.fillText("Nenhuma imagem carregada.", 14 * (window.devicePixelRatio || 1), 26 * (window.devicePixelRatio || 1));
                    cctx.fillStyle = "rgba(255,255,255,.50)";
                    cctx.fillText("Use “Carregar imagem”.", 14 * (window.devicePixelRatio || 1), 46 * (window.devicePixelRatio || 1));
                    cctx.restore();
                    return;
                }

                cctx.save();
                cctx.imageSmoothingEnabled = false;
                cctx.translate(conv.view.ox, conv.view.oy);
                cctx.scale(conv.view.scale, conv.view.scale);
                cctx.drawImage(conv.img, 0, 0);

                // se existir resultado, desenha overlay do grid convertido (preview pixelado)
                if (conv.last && conv.last.previewCanvas) {
                    cctx.globalAlpha = 0.65;
                    cctx.drawImage(conv.last.previewCanvas, 0, 0, conv.img.width, conv.img.height);
                    cctx.globalAlpha = 1;
                }

                cctx.restore();
            }

            function convResetView() {
                if (!conv.img) {
                    conv.view.scale = 1; conv.view.ox = 0; conv.view.oy = 0;
                    el.convertImgZoom.value = 100;
                    el.convertImgZoomLbl.textContent = "100%";
                    drawConvertPreview();
                    return;
                }
                const w = el.convertImgCanvas.width;
                const h = el.convertImgCanvas.height;
                const iw = conv.img.width;
                const ih = conv.img.height;

                const fit = Math.min(w / iw, h / ih) * 0.95;
                conv.view.scale = Math.max(conv.view.minScale, Math.min(conv.view.maxScale, fit));
                conv.view.ox = (w - iw * conv.view.scale) / 2;
                conv.view.oy = (h - ih * conv.view.scale) / 2;

                const pct = Math.round(conv.view.scale * 100);
                el.convertImgZoom.value = clampInt(pct, 10, 600);
                el.convertImgZoomLbl.textContent = `${el.convertImgZoom.value}%`;
                drawConvertPreview();
            }

            function setConvZoomPercent(pct, anchorX = null, anchorY = null) {
                pct = clampInt(pct, 10, 600);
                const newScale = pct / 100;

                const w = el.convertImgCanvas.width;
                const h = el.convertImgCanvas.height;
                const ax = (anchorX == null) ? (w / 2) : anchorX;
                const ay = (anchorY == null) ? (h / 2) : anchorY;

                const ix = (ax - conv.view.ox) / conv.view.scale;
                const iy = (ay - conv.view.oy) / conv.view.scale;

                conv.view.scale = Math.max(conv.view.minScale, Math.min(conv.view.maxScale, newScale));
                conv.view.ox = ax - ix * conv.view.scale;
                conv.view.oy = ay - iy * conv.view.scale;

                el.convertImgZoom.value = pct;
                el.convertImgZoomLbl.textContent = `${pct}%`;
                drawConvertPreview();
            }

            function convEvtToCanvasXY(evt) {
                const rect = el.convertImgCanvas.getBoundingClientRect();
                const dpr = window.devicePixelRatio || 1;
                return { x: (evt.clientX - rect.left) * dpr, y: (evt.clientY - rect.top) * dpr };
            }

            function scheduleConvertPreview() {
                if (!el.convertAutoApply.checked) return;
                clearTimeout(conv.debounceT);
                conv.debounceT = setTimeout(() => {
                    try {
                        buildConversionPreview();
                        updateBeadsPreviewFromLast();
                    } catch { }
                }, 120);
            }

            function computeGridFromMaxSide(maxSide, imgW, imgH) {
                maxSide = clampInt(maxSide, 8, 400);
                const aspect = imgW / imgH;
                let cols, rows;
                if (aspect >= 1) {
                    cols = maxSide;
                    rows = Math.max(1, Math.round(cols / aspect));
                } else {
                    rows = maxSide;
                    cols = Math.max(1, Math.round(rows * aspect));
                }
                cols = clampInt(cols, 1, 400);
                rows = clampInt(rows, 1, 400);
                return { cols, rows };
            }

            function distRedmean(c1, c2) {
                const rmean = (c1.r + c2.r) >> 1;
                const r = c1.r - c2.r;
                const g = c1.g - c2.g;
                const b = c1.b - c2.b;
                return Math.sqrt((((512 + rmean) * r * r) >> 8) + 4 * g * g + (((767 - rmean) * b * b) >> 8));
            }

            function nearestPaletteIndexRGB(palRGB, rgb) {
                let best = 0;
                let bd = Infinity;
                for (let i = 0; i < palRGB.length; i++) {
                    const d = distRedmean(palRGB[i], rgb);
                    if (d < bd) { bd = d; best = i; }
                }
                return best;
            }

            function kmeansQuantize(pixelsRGB, k, iters) {
                // pixelsRGB: Array<{r,g,b}>
                k = clampInt(k, 2, 96);
                iters = clampInt(iters, 3, 30);

                const n = pixelsRGB.length;
                if (n === 0) return [];
                if (n <= k) return pixelsRGB.map(p => ({ r: p.r, g: p.g, b: p.b }));

                const cent = [];

                // --- K-Means++ Initialization ---
                // 1. First center at random
                const firstIdx = Math.floor(Math.random() * n);
                cent.push({ ...pixelsRGB[firstIdx] });

                // Distances to nearest existing center
                const minDistSq = new Float64Array(n);
                // Init with distance to first center
                for (let i = 0; i < n; i++) {
                    const d = distRedmean(pixelsRGB[i], cent[0]);
                    minDistSq[i] = d * d;
                }

                // 2. Choose remaining k-1 centers
                for (let c = 1; c < k; c++) {
                    let sumSq = 0;
                    for (let i = 0; i < n; i++) sumSq += minDistSq[i];

                    const target = Math.random() * sumSq;
                    let currentSum = 0;
                    let nextIdx = -1;

                    for (let i = 0; i < n; i++) {
                        currentSum += minDistSq[i];
                        if (currentSum >= target) {
                            nextIdx = i;
                            break;
                        }
                    }
                    if (nextIdx === -1) nextIdx = n - 1;

                    const newCent = pixelsRGB[nextIdx];
                    cent.push({ ...newCent });

                    // Update min distances for all pixels
                    for (let i = 0; i < n; i++) {
                        const d = distRedmean(pixelsRGB[i], newCent);
                        const d2 = d * d;
                        if (d2 < minDistSq[i]) minDistSq[i] = d2;
                    }
                }

                const assign = new Int16Array(n);

                for (let iter = 0; iter < iters; iter++) {
                    let changedCount = 0;
                    // assignment
                    for (let i = 0; i < n; i++) {
                        const best = nearestPaletteIndexRGB(cent, pixelsRGB[i]);
                        if (assign[i] !== best) {
                            assign[i] = best;
                            changedCount++;
                        }
                    }

                    // If no pixels changed cluster, we converged
                    if (changedCount === 0 && iter > 0) break;

                    // update
                    const sr = new Float64Array(k);
                    const sg = new Float64Array(k);
                    const sb = new Float64Array(k);
                    const sc = new Int32Array(k);

                    for (let i = 0; i < n; i++) {
                        const a = assign[i];
                        const p = pixelsRGB[i];
                        sr[a] += p.r; sg[a] += p.g; sb[a] += p.b; sc[a] += 1;
                    }
                    for (let j = 0; j < k; j++) {
                        if (sc[j] === 0) {
                            // Re-init empty cluster with random pixel
                            const p = pixelsRGB[(Math.random() * n) | 0];
                            cent[j] = { r: p.r, g: p.g, b: p.b };
                            continue;
                        }
                        cent[j] = { r: sr[j] / sc[j], g: sg[j] / sc[j], b: sb[j] / sc[j] };
                    }
                }

                // normaliza para 0..255 ints
                return cent.map(c => ({ r: clampInt(c.r, 0, 255), g: clampInt(c.g, 0, 255), b: clampInt(c.b, 0, 255) }));
            }

            function renderBeadsPreview(canvas, rows, cols, grid, cellSize, viewMode) {
                if (!canvas) return;

                const w = cols * cellSize;
                const h = rows * cellSize;

                // Resize canvas to actual dimension (Zoom works now)
                if (canvas.width !== w || canvas.height !== h) {
                    canvas.width = w;
                    canvas.height = h;
                }

                const pctx = canvas.getContext("2d");

                // Reuse renderTo logic logic for consistency
                // We can't call renderTo directly because it relies on 'state' global object for cols/rows/grid
                // So we duplicate the drawing logic slightly adapted for arguments.

                pctx.clearRect(0, 0, w, h);

                // Background match main board
                pctx.fillStyle = "rgba(255,255,255,.03)";
                pctx.fillRect(0, 0, w, h);

                // Grid Lines match main board
                pctx.strokeStyle = "rgba(255,255,255,.06)";
                pctx.lineWidth = 1;
                pctx.beginPath();
                for (let c = 0; c <= cols; c++) {
                    const x = c * cellSize + 0.5;
                    pctx.moveTo(x, 0); pctx.lineTo(x, h);
                }
                for (let r = 0; r <= rows; r++) {
                    const y = r * cellSize + 0.5;
                    pctx.moveTo(0, y); pctx.lineTo(w, y);
                }
                pctx.stroke();

                // Beads drawing
                for (let r = 0; r < rows; r++) {
                    for (let c = 0; c < cols; c++) {
                        const hex = grid[r * cols + c];
                        if (!hex) continue;
                        const x = c * cellSize, y = r * cellSize;
                        const cs = cellSize;

                        if (viewMode === "pixel") {
                            pctx.fillStyle = hex;
                            pctx.fillRect(x + 1, y + 1, cs - 2, cs - 2);
                            continue;
                        }

                        if (viewMode === "round") {
                            const pad = Math.max(1, Math.floor(cs * 0.04));
                            const cx = x + cs / 2, cy = y + cs / 2;
                            const rad = (cs / 2) - pad;

                            pctx.beginPath();
                            pctx.arc(cx, cy, rad, 0, Math.PI * 2);
                            pctx.fillStyle = hex;
                            pctx.fill();

                            pctx.save();
                            pctx.beginPath();
                            pctx.arc(cx, cy, rad * 0.35, 0, Math.PI * 2);
                            pctx.fillStyle = "#0b1224"; // Hole color matching main board
                            pctx.fill();
                            pctx.restore();
                            continue;
                        }

                        // Melted (Rounded Rect style from main board)
                        const radius = Math.max(2, cs * 0.22);
                        pctx.save();
                        pctx.fillStyle = hex;

                        // drawRoundedRect inline implementation
                        const rr = Math.min(radius, cs / 2);
                        pctx.beginPath();
                        pctx.moveTo(x + rr, y);
                        pctx.arcTo(x + cs, y, x + cs, y + cs, rr);
                        pctx.arcTo(x + cs, y + cs, x, y + cs, rr);
                        pctx.arcTo(x, y + cs, x, y, rr);
                        pctx.arcTo(x, y, x + cs, y, rr);
                        pctx.closePath();

                        pctx.fill();

                        pctx.globalAlpha = 0.10;
                        pctx.fillStyle = "#ffffff";

                        // highlight rect
                        const hx = x + cs * 0.10;
                        const hy = y + cs * 0.10;
                        const hw = cs * 0.55;
                        const hh = cs * 0.28;
                        const hr = Math.max(2, cs * 0.18);
                        const hrr = Math.min(hr, hw / 2, hh / 2);

                        pctx.beginPath();
                        pctx.moveTo(hx + hrr, hy);
                        pctx.arcTo(hx + hw, hy, hx + hw, hy + hh, hrr);
                        pctx.arcTo(hx + hw, hy + hh, hx, hy + hh, hrr);
                        pctx.arcTo(hx, hy + hh, hx, hy, hrr);
                        pctx.arcTo(hx, hy, hx + hw, hy, hrr);
                        pctx.closePath();

                        pctx.fill();
                        pctx.restore();
                    }
                }
            }

            function updateBeadsPreviewFromLast() {
                if (!conv.last) return;
                const cs = clampInt(el.convertPreviewCellSize.value, 2, 28);
                el.convertPreviewCellSizeLbl.textContent = `${cs} px`;

                const mode = el.convertPreviewMode ? el.convertPreviewMode.value : "melted";

                renderBeadsPreview(
                    el.convertBeadsPreviewCanvas,
                    conv.last.rows,
                    conv.last.cols,
                    conv.last.grid,
                    cs,
                    mode
                );
            }

            function buildConversionPreview() {
                if (!conv.img) {
                    conv.last = null;
                    el.convertStats.textContent = "Nenhuma imagem carregada.";
                    drawConvertPreview();
                    updateBeadsPreviewFromLast();
                    return;
                }

                const mode = el.convertColorMode.value; // usePalette | quantizeNew
                const lock = !!el.convertLockAspect.checked;

                let cols = clampInt(el.convertCols.value, 1, 400);
                let rows = clampInt(el.convertRows.value, 1, 400);

                if (lock) {
                    const ms = clampInt(el.convertMaxSide.value, 8, 400);
                    const g = computeGridFromMaxSide(ms, conv.img.width, conv.img.height);
                    cols = g.cols; rows = g.rows;
                    el.convertCols.value = cols;
                    el.convertRows.value = rows;
                }




                // desenha imagem no offscreen com o tamanho do grid (1 pixel = 1 bead)
                const w = cols, h = rows;
                conv.off.width = w;
                conv.off.height = h;
                conv.offCtx.clearRect(0, 0, w, h);
                conv.offCtx.imageSmoothingEnabled = true; // suaviza ao reduzir (melhor para conversão)
                conv.offCtx.drawImage(conv.img, 0, 0, w, h);

                const imgData = conv.offCtx.getImageData(0, 0, w, h);
                const data = imgData.data;

                // coleta pixels (subamostragem para kmeans quando grid grande)
                const pixels = [];
                const step = (w * h > 60000) ? 2 : 1; // simples: reduz amostra
                for (let y = 0; y < h; y += step) {
                    for (let x = 0; x < w; x += step) {
                        const i = (y * w + x) * 4;
                        const a = data[i + 3];
                        if (a < 10) continue; // ignora quase transparente
                        pixels.push({ r: data[i], g: data[i + 1], b: data[i + 2] });
                    }
                }

                let paletteHex = [];
                let paletteRGB = [];

                if (mode === "usePalette") {
                    // usa cores existentes
                    paletteHex = state.palette.map(p => normalizeHex(p.color)).filter(Boolean);
                    if (!paletteHex.length) paletteHex = ["#000000", "#ffffff"];
                    paletteRGB = paletteHex.map(hexToRgb);
                } else {
                    // gera paleta via kmeans
                    const k = clampInt(el.convertK.value, 2, 96);
                    const iters = clampInt(el.convertIters.value, 3, 30);
                    const cent = kmeansQuantize(pixels, k, iters);
                    paletteRGB = cent;
                    paletteHex = cent.map(c => rgbToHex(c.r, c.g, c.b));
                }

                const dither = !!el.convertDither.checked;

                // mapeia pixels para paleta, com ou sem dithering
                const outGrid = new Array(w * h).fill("");
                const errR = new Float32Array(w * h);
                const errG = new Float32Array(w * h);
                const errB = new Float32Array(w * h);

                function getRGBAt(i) {
                    const r = data[i] + (dither ? errR[i >> 2] : 0);
                    const g = data[i + 1] + (dither ? errG[i >> 2] : 0);
                    const b = data[i + 2] + (dither ? errB[i >> 2] : 0);
                    return { r: clampInt(r, 0, 255), g: clampInt(g, 0, 255), b: clampInt(b, 0, 255) };
                }

                // preview canvas (overlay), no tamanho original da imagem para sobrepor “pixelado”
                const prev = document.createElement("canvas");
                prev.width = conv.img.width;
                prev.height = conv.img.height;
                const pctx = prev.getContext("2d");
                pctx.imageSmoothingEnabled = false;

                // canvas intermediário na resolução do grid
                const mini = document.createElement("canvas");
                mini.width = w; mini.height = h;
                const mctx2 = mini.getContext("2d");
                const out = mctx2.createImageData(w, h);

                for (let y = 0; y < h; y++) {
                    for (let x = 0; x < w; x++) {
                        const pi = y * w + x;
                        const i = pi * 4;
                        const a = data[i + 3];
                        if (a < 10) {
                            outGrid[pi] = "";
                            out.data[i] = 0; out.data[i + 1] = 0; out.data[i + 2] = 0; out.data[i + 3] = 0;
                            continue;
                        }

                        const rgb = getRGBAt(i);
                        const idxPal = nearestPaletteIndexRGB(paletteRGB, rgb);
                        const ph = paletteHex[idxPal];

                        outGrid[pi] = ph;

                        const prgb = paletteRGB[idxPal];
                        out.data[i] = prgb.r;
                        out.data[i + 1] = prgb.g;
                        out.data[i + 2] = prgb.b;
                        out.data[i + 3] = 255;

                        if (dither) {
                            // Floyd–Steinberg
                            const er = rgb.r - prgb.r;
                            const eg = rgb.g - prgb.g;
                            const eb = rgb.b - prgb.b;

                            const addErr = (xx, yy, f) => {
                                if (xx < 0 || yy < 0 || xx >= w || yy >= h) return;
                                const p2 = yy * w + xx;
                                errR[p2] += er * f;
                                errG[p2] += eg * f;
                                errB[p2] += eb * f;
                            };

                            addErr(x + 1, y, 7 / 16);
                            addErr(x - 1, y + 1, 3 / 16);
                            addErr(x, y + 1, 5 / 16);
                            addErr(x + 1, y + 1, 1 / 16);
                        }
                    }
                }

                mctx2.putImageData(out, 0, 0);

                // amplia para tamanho da imagem (overlay)
                pctx.clearRect(0, 0, prev.width, prev.height);
                pctx.drawImage(mini, 0, 0, prev.width, prev.height);

                // estatísticas
                const usedSet = new Set(outGrid.filter(Boolean));
                el.convertStats.textContent =
                    `Imagem: ${conv.img.width}×${conv.img.height} | Grid: ${w}×${h} | Cores no resultado: ${usedSet.size}` +
                    (mode === "usePalette" ? ` | Paleta atual: ${state.palette.length}` : ` | K solicitado: ${paletteHex.length}`) +
                    (dither ? " | Dither: ON" : " | Dither: OFF");

                conv.last = {
                    cols: w,
                    rows: h,
                    grid: outGrid,
                    paletteHex,
                    mode,
                    previewCanvas: prev
                };

                drawConvertPreview();
            }

            function openImgToBeadsDialog() {
                el.dlgImgToBeads.showModal();
                convCanvasResizeToWrap();
                drawConvertPreview();
                if (conv.img) convResetView();
            }

            function applyConversionToProject() {
                if (!conv.last || !conv.last.grid) {
                    alert("Gere o preview primeiro (ou carregue uma imagem).");
                    return;
                }

                const { rows, cols, grid, paletteHex, mode } = conv.last;

                // redimensiona board (não mantém o trabalho atual)
                applyResize(rows, cols, false);

                // aplica paleta se for quantizada
                if (mode === "quantizeNew") {
                    const replace = !!el.convertReplacePalette.checked;

                    const newPal = paletteHex.map((hx, i) => ({
                        id: uid(),
                        name: `IMG-${String(i + 1).padStart(2, "0")}`,
                        color: normalizeHex(hx) || "#ffffff"
                    }));

                    if (replace) {
                        state.paletteName = `Imagem (${newPal.length})`;
                        state.palette = newPal;
                        state.selectedColorId = state.palette[0]?.id ?? null;
                    } else {
                        // adiciona ao final (evita duplicatas exatas)
                        const existing = new Set(state.palette.map(p => normalizeHex(p.color)).filter(Boolean));
                        for (const p of newPal) {
                            const hx = normalizeHex(p.color);
                            if (existing.has(hx)) continue;
                            state.palette.push(p);
                            existing.add(hx);
                        }
                        if (!state.selectedColorId && state.palette[0]) state.selectedColorId = state.palette[0].id;
                        state.paletteName = state.paletteName || "Paleta (sem nome)";
                    }
                }

                // preenche grid
                state.grid = grid.slice(0, rows * cols);
                if (state.grid.length < rows * cols) {
                    state.grid = state.grid.concat(new Array(rows * cols - state.grid.length).fill(""));
                }

                // finaliza
                state.dirty = true;
                renderPalette();
                renderBoard();
                renderUsedPanel();
                updateStatus();
                autosave();
            }



            // ===== Eventos =====
            let isDown = false;
            let lastCell = null;
            let lastCoordText = "";

            function colLetterFromIndex(c) { return String.fromCharCode(65 + c); }
            function updateCoordText(r, c) {
                if (!inBounds(r, c)) { lastCoordText = ""; return; }
                const colL = colLetterFromIndex(c);
                const rowN = r + 1;
                const index = r * state.cols + c + 1;
                lastCoordText = `Cursor: ${index} (${colL}${rowN})`;
            }

            function applyAt(r, c, { forceErase = false, shift = false } = {}) {
                if (!inBounds(r, c)) return;

                const tool = forceErase ? "erase" : state.tool;

                if (["line", "rect", "ellipse"].includes(tool)) {
                    if (isDown) {
                        if (!state.shapes.start) state.shapes.start = { r, c };
                        state.shapes.current = { r, c };
                        renderBoard();
                    }
                    return;
                }

                if (tool === "polygon") {
                    // Polygon logic is handled in pointerdown/click usually, 
                    // but we can update preview here
                    state.shapes.current = { r, c };
                    renderBoard();
                    return;
                }

                if (tool === "picker") {
                    const hex = getCell(r, c);
                    if (hex) {
                        setSelectedColorByHex(hex);
                        state.tool = "paint";
                        updateStatus();
                    }
                    return;
                }

                if (tool === "rectSelect" || tool === "lassoSelect") {
                    if (state.selection.active) {
                        // Check if click is inside selection to move it
                        let inside = false;
                        const s_ox = state.selection.ox || 0;
                        const s_oy = state.selection.oy || 0;
                        if (state.selection.type === "rect") {
                            const { r1, c1, r2, c2 } = state.selection.rect;
                            const minR = Math.min(r1, r2) + s_oy, maxR = Math.max(r1, r2) + s_oy;
                            const minC = Math.min(c1, c2) + s_ox, maxC = Math.max(c1, c2) + s_ox;
                            if (r >= minR && r <= maxR && c >= minC && c <= maxC) inside = true;
                        } else {
                            if (isPointInPoly(state.selection.points, r - s_oy, c - s_ox)) inside = true;
                        }

                        if (inside && isDown) {
                            if (!state.selection.isMoving) {
                                state.selection.isMoving = true;
                                state.selection.startMove = { r, c, ox: state.selection.ox, oy: state.selection.oy };
                            } else {
                                state.selection.ox = state.selection.startMove.ox + (c - state.selection.startMove.c);
                                state.selection.oy = state.selection.startMove.oy + (r - state.selection.startMove.r);
                            }
                        } else if (isDown && !state.selection.isMoving) {
                            commitSelection();
                            state.selection.active = false;
                            state.selection.points = [{ r, c }];
                            state.selection.type = (tool === "rectSelect" ? "rect" : "lasso");
                            if (tool === "rectSelect") state.selection.rect = { r1: r, c1: c, r2: r, c2: c };
                            else state.selection.rect = null;
                        }
                    } else if (isDown) {
                        if (state.selection.points.length === 0) {
                            state.selection.points = [{ r, c }];
                            state.selection.type = (tool === "rectSelect" ? "rect" : "lasso");
                            if (tool === "rectSelect") state.selection.rect = { r1: r, c1: c, r2: r, c2: c };
                            else state.selection.rect = null;
                        } else {
                            if (tool === "rectSelect") {
                                state.selection.rect.r2 = r;
                                state.selection.rect.c2 = c;
                            } else {
                                const last = state.selection.points[state.selection.points.length - 1];
                                if (last.r !== r || last.c !== c) state.selection.points.push({ r, c });
                            }
                        }
                    }
                    renderBoard();
                    return;
                } else if (state.selection.active) {
                    commitSelection();
                }

                if (["line", "rect", "ellipse"].includes(tool)) {
                    if (isDown) {
                        if (!state.shapes.start) state.shapes.start = { r, c };
                        state.shapes.current = { r, c };
                        renderBoard();
                    }
                    return;
                }

                if (tool === "polygon") {
                    state.shapes.current = { r, c };
                    renderBoard();
                    return;
                }

                const hex = (tool === "erase") ? "" : getSelectedColor();

                if (tool === "bucket") {
                    pushHistory();
                    floodFill(r, c, hex);
                    if (state.mirror) floodFill(r, state.cols - 1 - c, hex);
                } else {
                    if (shift && lastCell) {
                        drawLine(lastCell.r, lastCell.c, r, c, hex);
                        if (state.mirror) drawLine(lastCell.r, state.cols - 1 - lastCell.c, r, state.cols - 1 - c, hex);
                    } else {
                        setCell(r, c, hex);
                        if (state.mirror) setCell(r, state.cols - 1 - c, hex);
                    }
                }

                lastCell = { r, c };
                renderBoard();
                renderUsedPanel();
                updateStatus();
            }

            el.board.addEventListener("contextmenu", (e) => e.preventDefault());
            el.board.addEventListener("pointerdown", (e) => {
                const { r, c } = canvasToCell(e);
                updateCoordText(r, c);

                if (state.tool === "polygon") {
                    const found = state.shapes.points.find(p => p.r === r && p.c === c);
                    if (!found) {
                        if (state.shapes.points.length === 0) pushHistory();
                        state.shapes.points.push({ r, c });
                        renderBoard();
                    }
                } else if (state.tool !== "picker") {
                    pushHistory();
                }

                el.board.setPointerCapture(e.pointerId);
                isDown = true;
                const forceErase = (e.button === 2) || (e.buttons === 2);
                applyAt(r, c, { forceErase, shift: e.shiftKey });
            });
            el.board.addEventListener("pointermove", (e) => {
                const { r, c } = canvasToCell(e);
                updateCoordText(r, c);
                if (!isDown) {
                    if (["line", "rect", "ellipse", "polygon"].includes(state.tool)) {
                        state.shapes.current = { r, c };
                        renderBoard();
                    }
                    updateStatus();
                    return;
                }
                const forceErase = (e.buttons === 2);
                applyAt(r, c, { forceErase, shift: e.shiftKey });
            });
            el.board.addEventListener("pointerup", () => {
                if (isDown && ["line", "rect", "ellipse"].includes(state.tool)) {
                    const hex = getSelectedColor();
                    let pts = [];
                    const s = state.shapes.start, cur = state.shapes.current;
                    if (s && cur) {
                        if (state.tool === "line") pts = getLinePoints(s.r, s.c, cur.r, cur.c);
                        else if (state.tool === "rect") pts = getRectPoints(s.r, s.c, cur.r, cur.c);
                        else if (state.tool === "ellipse") pts = getEllipsePoints(s.r, s.c, cur.r, cur.c);

                        for (const p of pts) if (inBounds(p.r, p.c)) setCell(p.r, p.c, hex);
                        state.dirty = true;
                        renderBoard();
                        renderUsedPanel();
                        autosave();
                    }
                    state.shapes.start = null;
                    state.shapes.current = null;
                }
                if (isDown && (state.tool === "rectSelect" || state.tool === "lassoSelect")) {
                    if (state.selection.isMoving) {
                        state.selection.isMoving = false;
                        state.dirty = true;
                        autosave();
                    } else {
                        let hasSel = false;
                        if (state.selection.type === "rect") {
                            const { r1, c1, r2, c2 } = state.selection.rect;
                            if (r1 !== r2 || c1 !== c2) hasSel = true;
                        } else {
                            if (state.selection.points.length > 2) hasSel = true;
                        }

                        if (hasSel) {
                            // Finalize selection
                            state.selection.active = true;
                            state.selection.ox = 0;
                            state.selection.oy = 0;

                            // Extract pixels
                            const floating = [];
                            if (state.selection.type === "rect") {
                                const { r1, c1, r2, c2 } = state.selection.rect;
                                const minR = Math.min(r1, r2), maxR = Math.max(r1, r2);
                                const minC = Math.min(c1, c2), maxC = Math.max(c1, c2);
                                for (let r = minR; r <= maxR; r++) {
                                    for (let c = minC; c <= maxC; c++) {
                                        const h = getCell(r, c);
                                        if (h) {
                                            floating.push({ r, c, hex: h });
                                            setCell(r, c, "");
                                        }
                                    }
                                }
                            } else {
                                // Lasso - find bounds first
                                let minR = Infinity, maxR = -Infinity, minC = Infinity, maxC = -Infinity;
                                for (const p of state.selection.points) {
                                    minR = Math.min(minR, p.r); maxR = Math.max(maxR, p.r);
                                    minC = Math.min(minC, p.c); maxC = Math.max(maxC, p.c);
                                }
                                for (let r = minR; r <= maxR; r++) {
                                    for (let c = minC; c <= maxC; c++) {
                                        if (isPointInPoly(state.selection.points, r, c)) {
                                            const h = getCell(r, c);
                                            if (h) {
                                                floating.push({ r, c, hex: h });
                                                setCell(r, c, "");
                                            }
                                        }
                                    }
                                }
                            }
                            state.selection.floating = floating;
                            state.dirty = true;
                            renderBoard();
                            renderUsedPanel();
                            autosave();
                        } else {
                            // Clicked but didn't drag/lasso
                            state.selection.points = [];
                            state.selection.rect = null;
                            renderBoard();
                        }
                    }
                }
                isDown = false;
            });
            el.board.addEventListener("pointercancel", () => { isDown = false; });

            el.viewMode.addEventListener("change", () => {
                state.viewMode = el.viewMode.value;
                if (el.dlgImgToBeads?.open) updateBeadsPreviewFromLast();
                renderBoard();
                updateStatus();
                autosave();
            });

            el.toolButtons.forEach(btn => {
                btn.addEventListener("click", () => {
                    const t = btn.getAttribute("data-tool");
                    if (["flip-h", "flip-v", "rotate"].includes(t)) {
                        // Acciones inmediatas
                        if (t === "rotate") rotate90();
                        if (t === "flip-h") flipHorizontal();
                        if (t === "flip-v") flipVertical();
                        return;
                    }
                    if (state.selection.active) commitSelection();
                    state.tool = t;
                    updateStatus();
                });
            });

            el.chkFill.addEventListener("change", () => {
                state.fillShapes = el.chkFill.checked;
            });

            el.cellSize.addEventListener("input", () => {
                state.cellSize = clampInt(el.cellSize.value, 6, 42);
                el.cellSizeLabel.textContent = `${state.cellSize} px`;
                resizeCanvasToBoard();
                autosave();
            });

            el.chkMirror.addEventListener("change", () => {
                state.mirror = !!el.chkMirror.checked;
            });

            el.palSearch.addEventListener("input", renderPalette);

            el.btnHelp.addEventListener("click", () => el.dlgHelp.showModal());

            // Dropdowns
            el.dropdowns = document.querySelectorAll(".dropdown");
            el.dropdowns.forEach(dd => {
                const btn = dd.querySelector(".dropdown-toggle");
                btn.addEventListener("click", (e) => {
                    e.stopPropagation();
                    const wasActive = dd.classList.contains("show");
                    el.dropdowns.forEach(d => d.classList.remove("show"));
                    if (!wasActive) dd.classList.add("show");
                });
            });

            window.addEventListener("click", () => {
                el.dropdowns.forEach(d => d.classList.remove("show"));
            });

            el.btnUndo.addEventListener("click", () => {
                el.dropdowns.forEach(d => d.classList.remove("show"));
                undo();
            });

            el.btnRedo.addEventListener("click", () => {
                el.dropdowns.forEach(d => d.classList.remove("show"));
                redo();
            });

            el.btnNewProject.addEventListener("click", () => {
                el.dropdowns.forEach(d => d.classList.remove("show"));
                if (!confirm("Criar novo projeto? Isso limpa o grid e a paleta atual.")) return;
                history.undoStack = [];
                history.redoStack = [];
                newProject();
            });

            el.btnResize.addEventListener("click", () => {
                el.dropdowns.forEach(d => d.classList.remove("show"));
                openResizeDialog();
            });

            el.dlgResizeClose.addEventListener("click", () => closeDialog(el.dlgResize));
            el.dlgResizeApply.addEventListener("click", () => {
                applyResize(el.resizeRows.value, el.resizeCols.value, el.resizeKeep.checked);
                closeDialog(el.dlgResize);
            });

            el.btnClear.addEventListener("click", () => {
                el.dropdowns.forEach(d => d.classList.remove("show"));
                if (!confirm("Limpar todo o board?")) return;
                pushHistory();
                state.selection.active = false;
                state.selection.floating = null;
                state.selection.points = [];
                state.grid = makeEmptyGrid(state.rows, state.cols);
                state.dirty = true;
                renderBoard();
                renderUsedPanel();
                updateStatus();
                autosave();
            });

            el.btnSave.addEventListener("click", () => {
                el.dropdowns.forEach(d => d.classList.remove("show"));
                askSaveNameAndSave();
            });

            el.btnOpen.addEventListener("click", () => {
                el.dropdowns.forEach(d => d.classList.remove("show"));
                el.fileOpen.click();
            });

            el.btnExportPng.addEventListener("click", () => {
                el.dropdowns.forEach(d => d.classList.remove("show"));
                exportPngWithUsedList();
            });

            el.btnResetView.addEventListener("click", () => {
                el.dropdowns.forEach(d => d.classList.remove("show"));
                // encontra limites do desenho
                let minR = Infinity, maxR = -Infinity;
                let minC = Infinity, maxC = -Infinity;

                for (let r = 0; r < state.rows; r++) {
                    for (let c = 0; c < state.cols; c++) {
                        const v = state.grid[r * state.cols + c];
                        if (!v) continue;

                        if (r < minR) minR = r;
                        if (r > maxR) maxR = r;
                        if (c < minC) minC = c;
                        if (c > maxC) maxC = c;
                    }
                }

                if (!isFinite(minR)) {
                    alert("Não há beads no board para centralizar.");
                    return;
                }

                const drawH = maxR - minR + 1;
                const drawW = maxC - minC + 1;
                const centerR = Math.floor(state.rows / 2);
                const centerC = Math.floor(state.cols / 2);
                const targetMinR = centerR - Math.floor(drawH / 2);
                const targetMinC = centerC - Math.floor(drawW / 2);

                const newGrid = new Array(state.rows * state.cols).fill("");

                for (let r = minR; r <= maxR; r++) {
                    for (let c = minC; c <= maxC; c++) {
                        const v = state.grid[r * state.cols + c];
                        if (!v) continue;
                        const nr = r - minR + targetMinR;
                        const nc = c - minC + targetMinC;
                        if (nr >= 0 && nr < state.rows && nc >= 0 && nc < state.cols) {
                            newGrid[nr * state.cols + nc] = v;
                        }
                    }
                }

                state.grid = newGrid;
                state.dirty = true;
                renderBoard();
                renderUsedPanel();
                updateStatus();
                autosave();
            });


            document.querySelectorAll(".btnAddColorAction").forEach(btn => {
                btn.addEventListener("click", () => {
                    el.dropdowns.forEach(d => d.classList.remove("show"));
                    openColorDialog(null);
                });
            });

            el.btnManageColors.addEventListener("click", () => {
                el.dropdowns.forEach(d => d.classList.remove("show"));
                renderManagePalette();
                openManageDialog();
            });

            el.dlgColorClose.addEventListener("click", () => closeDialog(el.dlgColor));
            el.dlgColorSave.addEventListener("click", () => {
                const name = el.colorName.value;
                const hex = el.colorHex.value;

                if (editingColorId) {
                    const p = state.palette.find(x => x.id === editingColorId);
                    const oldHex = normalizeHex(p?.color);
                    updateColor(editingColorId, name, hex);
                    const newHex = normalizeHex(state.palette.find(x => x.id === editingColorId)?.color);
                    if (oldHex && newHex && oldHex !== newHex) {
                        state.grid = state.grid.map(v => (normalizeHex(v) === oldHex ? newHex : v));
                    }
                } else {
                    addColor(name, hex);
                }

                state.dirty = true;
                renderPalette();
                renderManagePalette();
                renderBoard();
                renderUsedPanel();
                updateStatus();
                autosave();
                closeDialog(el.dlgColor);
            });

            el.dlgColorDelete.addEventListener("click", () => {
                if (!editingColorId) return;
                if (!confirm("Remover esta cor da paleta?\n\nObservação: pixels no board com esta cor serão apagados.")) return;
                deleteColor(editingColorId);
                editingColorId = null;
                renderPalette();
                renderManagePalette();
                renderBoard();
                renderUsedPanel();
                updateStatus();
                autosave();
                closeDialog(el.dlgColor);
            });

            el.dlgManageClose.addEventListener("click", () => closeDialog(el.dlgManage));
            el.dlgManageDone.addEventListener("click", () => closeDialog(el.dlgManage));

            // paleta: salvar/carregar
            el.btnSavePalette.addEventListener("click", () => {
                el.dropdowns.forEach(d => d.classList.remove("show"));
                askSavePalette();
            });

            el.btnLoadPalette.addEventListener("click", () => {
                el.dropdowns.forEach(d => d.classList.remove("show"));
                el.fileOpenPalette.click();
            });
            el.fileOpenPalette.addEventListener("change", async () => {
                const f = el.fileOpenPalette.files?.[0];
                el.fileOpenPalette.value = "";
                if (!f) return;

                showLoading(f.name);
                await new Promise(r => requestAnimationFrame(() => requestAnimationFrame(r)));

                try {
                    const obj = JSON.parse(await f.text());
                    deserializePalette(obj);

                    renderPalette();
                    renderManagePalette();
                    renderBoard();
                    renderUsedPanel();
                    updateStatus();
                    autosave();
                } catch (e) {
                    alert("Falha ao carregar paleta: " + (e?.message ?? e));
                } finally {
                    hideLoading();
                }
            });

            el.convertPreviewCellSize.addEventListener("input", () => {
                updateBeadsPreviewFromLast();
            });

            el.convertPreviewMode.addEventListener("change", () => {
                updateBeadsPreviewFromLast();
            });

            el.btnConvertPreview.addEventListener("click", () => {
                buildConversionPreview();
                updateBeadsPreviewFromLast();
            });


            // ===== Eventos: Imagem -> Beads =====
            el.btnImgToBeads.addEventListener("click", () => {
                el.dropdowns.forEach(d => d.classList.remove("show"));
                openImgToBeadsDialog();
            });
            el.dlgImgToBeadsClose.addEventListener("click", () => closeDialog(el.dlgImgToBeads));
            el.dlgImgToBeadsDone.addEventListener("click", () => closeDialog(el.dlgImgToBeads));

            el.btnLoadConvertImg.addEventListener("click", () => el.convertImgFile.click());
            el.convertImgFile.addEventListener("change", async () => {
                const f = el.convertImgFile.files?.[0];
                el.convertImgFile.value = "";
                if (!f) return;

                const url = URL.createObjectURL(f);
                try {
                    const img = new Image();
                    img.onload = () => {
                        conv.img = img;
                        conv.last = null;
                        convResetView();

                        // ajusta grid default pelo lado maior
                        const g = computeGridFromMaxSide(el.convertMaxSide.value, img.width, img.height);
                        el.convertCols.value = g.cols;
                        el.convertRows.value = g.rows;

                        buildConversionPreview();
                        URL.revokeObjectURL(url);
                    };
                    img.onerror = () => { URL.revokeObjectURL(url); alert("Não foi possível carregar a imagem."); };
                    img.src = url;
                } catch {
                    URL.revokeObjectURL(url);
                    alert("Falha ao carregar a imagem.");
                }
            });

            el.btnConvertResetView.addEventListener("click", convResetView);
            el.convertImgZoom.addEventListener("input", () => setConvZoomPercent(el.convertImgZoom.value));

            // pan/zoom no canvas de conversão
            el.convertImgCanvas.addEventListener("contextmenu", (e) => e.preventDefault());
            el.convertImgCanvas.addEventListener("pointerdown", (e) => {
                el.convertImgCanvas.setPointerCapture(e.pointerId);
                const { x, y } = convEvtToCanvasXY(e);
                const isRight = (e.button === 2) || (e.buttons === 2);
                if (isRight) {
                    conv.view.isPanning = true;
                    conv.view.lastX = x;
                    conv.view.lastY = y;
                    el.convertImgCanvas.classList.add("panning");
                    return;
                }
            });
            el.convertImgCanvas.addEventListener("pointermove", (e) => {
                if (!conv.view.isPanning) return;
                if (!(e.buttons & 2)) {
                    conv.view.isPanning = false;
                    el.convertImgCanvas.classList.remove("panning");
                    return;
                }
                const { x, y } = convEvtToCanvasXY(e);
                const dx = x - conv.view.lastX;
                const dy = y - conv.view.lastY;
                conv.view.lastX = x;
                conv.view.lastY = y;
                conv.view.ox += dx;
                conv.view.oy += dy;
                drawConvertPreview();
            });
            el.convertImgCanvas.addEventListener("pointerup", () => { conv.view.isPanning = false; el.convertImgCanvas.classList.remove("panning"); });
            el.convertImgCanvas.addEventListener("pointercancel", () => { conv.view.isPanning = false; el.convertImgCanvas.classList.remove("panning"); });

            el.convertImgCanvas.addEventListener("wheel", (e) => {
                e.preventDefault();
                const rect = el.convertImgCanvas.getBoundingClientRect();
                const dpr = window.devicePixelRatio || 1;
                const x = (e.clientX - rect.left) * dpr;
                const y = (e.clientY - rect.top) * dpr;
                const currentPct = clampInt(el.convertImgZoom.value, 10, 600);
                const step = (e.deltaY < 0) ? 10 : -10;
                setConvZoomPercent(currentPct + step, x, y);
            }, { passive: false });

            // controles -> atualizam preview
            [
                el.convertColorMode, el.convertMaxSide, el.convertLockAspect,
                el.convertCols, el.convertRows, el.convertK, el.convertIters,
                el.convertDither, el.convertReplacePalette, el.convertAutoApply
            ].forEach(inp => {
                if (!inp) return;
                inp.addEventListener("input", () => scheduleConvertPreview());
                inp.addEventListener("change", () => scheduleConvertPreview());
            });

            // se lock aspect ligado, mudanças em maxSide recalculam cols/rows
            el.convertMaxSide.addEventListener("input", () => {
                if (!conv.img) return;
                if (!el.convertLockAspect.checked) return;
                const g = computeGridFromMaxSide(el.convertMaxSide.value, conv.img.width, conv.img.height);
                el.convertCols.value = g.cols;
                el.convertRows.value = g.rows;
                scheduleConvertPreview();
            });

            // se lock aspect desligado, deixa o usuário editar cols/rows manualmente
            el.convertLockAspect.addEventListener("change", () => {
                scheduleConvertPreview();
            });

            el.btnConvertPreview.addEventListener("click", () => buildConversionPreview());
            el.btnConvertApply.addEventListener("click", () => {
                // garante preview atualizado se auto estiver desligado
                if (!el.convertAutoApply.checked) buildConversionPreview();
                applyConversionToProject();
            });



            // replace/help
            el.dlgReplaceClose.addEventListener("click", () => closeDialog(el.dlgReplace));
            el.dlgReplaceApply.addEventListener("click", () => {
                if (!replaceToHex) {
                    alert("Escolha uma cor para substituir.");
                    return;
                }
                applyReplace(replaceFromHex, replaceToHex);
                closeDialog(el.dlgReplace);
            });

            el.dlgReplaceDelete.addEventListener("click", () => {
                if (!confirm("Tem certeza que deseja apagar esta cor de todo o grid?")) return;
                applyReplace(replaceFromHex, ""); // troca por vazio
                closeDialog(el.dlgReplace);
            });

            el.btnHelp.addEventListener("click", () => el.dlgHelp.showModal());
            el.dlgHelpClose.addEventListener("click", () => closeDialog(el.dlgHelp));
            el.dlgHelpOk.addEventListener("click", () => closeDialog(el.dlgHelp));

            // gerenciar: imagem
            el.btnLoadManageImg.addEventListener("click", () => el.manageImgFile.click());
            el.manageImgFile.addEventListener("change", async () => {
                const f = el.manageImgFile.files?.[0];
                el.manageImgFile.value = "";
                if (!f) return;

                const url = URL.createObjectURL(f);
                try {
                    const img = new Image();
                    img.onload = () => {
                        mimg.img = img;
                        mimg.off.width = img.width;
                        mimg.off.height = img.height;
                        mimg.offCtx.clearRect(0, 0, img.width, img.height);
                        mimg.offCtx.drawImage(img, 0, 0);
                        manageResetView();
                        setManageSample(mimg.sampleHex || "#ffffff", `Imagem carregada: ${f.name}`);
                        URL.revokeObjectURL(url);
                    };
                    img.onerror = () => { URL.revokeObjectURL(url); alert("Não foi possível carregar a imagem."); };
                    img.src = url;
                } catch { URL.revokeObjectURL(url); alert("Falha ao carregar a imagem."); }
            });

            el.btnManageResetView.addEventListener("click", manageResetView);
            el.manageImgZoom.addEventListener("input", () => setManageZoomPercent(el.manageImgZoom.value));

            el.manageSampleColor.addEventListener("input", () => applySampleToSelectedColor(el.manageSampleColor.value));

            el.btnAddFromSample.addEventListener("click", () => {
                const name = String(el.manageNewColorName.value || "").trim();
                if (!name) { alert("Informe um nome para a nova cor (ex.: 2-C2)."); return; }
                const hex = normalizeHex(mimg.sampleHex);
                if (!hex) return;

                const id = addColor(name, hex);
                manageSelectedColorId = id;
                state.selectedColorId = id;
                el.manageNewColorName.value = "";

                state.dirty = true;
                renderPalette();
                renderManagePalette();
                renderUsedPanel();
                updateStatus();
                autosave();
            });

            el.manageImgCanvas.addEventListener("contextmenu", (e) => e.preventDefault());
            el.manageImgCanvas.addEventListener("pointerdown", (e) => {
                el.manageImgCanvas.setPointerCapture(e.pointerId);
                const { x, y } = manageCanvasEventToCanvasXY(e);
                const isRight = (e.button === 2) || (e.buttons === 2);
                if (isRight) {
                    mimg.isPanning = true;
                    mimg.lastX = x;
                    mimg.lastY = y;
                    el.manageImgCanvas.classList.add("panning");
                    return;
                }
                const hex = sampleColorAtCanvasXY(x, y);
                if (hex) applySampleToSelectedColor(hex);
                else setManageSample(mimg.sampleHex, "Fora da imagem / pixel transparente.");
            });

            el.manageImgCanvas.addEventListener("pointermove", (e) => {
                if (!mimg.isPanning) return;
                if (!(e.buttons & 2)) {
                    mimg.isPanning = false;
                    el.manageImgCanvas.classList.remove("panning");
                    return;
                }
                const { x, y } = manageCanvasEventToCanvasXY(e);
                const dx = x - mimg.lastX;
                const dy = y - mimg.lastY;
                mimg.lastX = x;
                mimg.lastY = y;
                mimg.ox += dx;
                mimg.oy += dy;
                drawManageImage();
            });

            el.manageImgCanvas.addEventListener("pointerup", () => { mimg.isPanning = false; el.manageImgCanvas.classList.remove("panning"); });
            el.manageImgCanvas.addEventListener("pointercancel", () => { mimg.isPanning = false; el.manageImgCanvas.classList.remove("panning"); });

            el.btnDeleteAllColors.addEventListener("click", () => {
                const ok = confirm(
                    "Deletar TODAS as cores da paleta?\n\n" +
                    "Observação: isso não apaga automaticamente o grid, mas as cores do grid que não existirem na paleta podem ficar sem referência."
                );
                if (!ok) return;

                state.palette = [];
                state.selectedColorId = null;
                manageSelectedColorId = null;

                state.dirty = true;
                renderPalette();
                renderManagePalette();
                renderUsedPanel();
                updateStatus();
                autosave();
            });

            el.manageImgCanvas.addEventListener("wheel", (e) => {
                e.preventDefault();
                const rect = el.manageImgCanvas.getBoundingClientRect();
                const dpr = window.devicePixelRatio || 1;
                const x = (e.clientX - rect.left) * dpr;
                const y = (e.clientY - rect.top) * dpr;
                const currentPct = clampInt(el.manageImgZoom.value, 10, 600);
                const step = (e.deltaY < 0) ? 10 : -10;
                setManageZoomPercent(currentPct + step, x, y);
            }, { passive: false });

            // right toggle
            function syncRightToggleUI() {
                const collapsed = document.body.classList.contains("right-collapsed");
                el.rightChev.textContent = collapsed ? "❮" : "❯";
                el.rightToggle.title = collapsed ? "Expandir painel de cores usadas" : "Recolher painel de cores usadas";
            }
            el.rightToggle.addEventListener("click", () => {
                document.body.classList.toggle("right-collapsed");
                syncRightToggleUI();
                placeRightToggle();
            });

            function placeRightToggle() {
                const collapsed = document.body.classList.contains("right-collapsed");
                const mainRect = document.querySelector("main").getBoundingClientRect();
                const topbarRect = document.getElementById("topbar").getBoundingClientRect();
                const footerRect = document.getElementById("bottom").getBoundingClientRect();

                const minTop = Math.round(topbarRect.bottom + 10);
                const maxTop = Math.round(footerRect.top - 46 - 10);

                if (collapsed) {
                    el.rightToggle.style.right = "10px";
                } else {
                    const rightRect = document.getElementById("right").getBoundingClientRect();
                    const px = Math.max(10, Math.round(window.innerWidth - rightRect.left + 10));
                    el.rightToggle.style.right = px + "px";
                }

                let targetTop = Math.round(mainRect.top + mainRect.height / 2 - 23);
                targetTop = Math.max(minTop, Math.min(maxTop, targetTop));
                el.rightToggle.style.top = targetTop + "px";
            }

            window.addEventListener("resize", () => {
                placeRightToggle();
                if (el.dlgImgToBeads.open) convCanvasResizeToWrap();
                if (el.dlgManage.open) manageCanvasResizeToWrap();
            });
            new ResizeObserver(placeRightToggle).observe(document.body);

            // atalhos
            window.addEventListener("keydown", (e) => {
                if (e.target && ["INPUT", "TEXTAREA", "SELECT"].includes(e.target.tagName)) return;
                if (e.key.toLowerCase() === "s" && e.ctrlKey) { e.preventDefault(); el.btnSave.click(); }
                if (e.key.toLowerCase() === "o" && e.ctrlKey) { e.preventDefault(); el.btnOpen.click(); }
                if (e.key.toLowerCase() === "z" && e.ctrlKey) { e.preventDefault(); undo(); }
                if (e.key.toLowerCase() === "y" && e.ctrlKey) { e.preventDefault(); redo(); }
                if (e.key === "Z" && e.ctrlKey && e.shiftKey) { e.preventDefault(); redo(); }

                if (!e.ctrlKey && !e.altKey && !e.metaKey) {
                    if (e.key.toLowerCase() === "p") {
                        const btn = Array.from(el.toolButtons).find(b => b.getAttribute("data-tool") === "polygon");
                        if (btn) btn.click();
                    }
                }

                if (e.key === "Escape") {
                    if (state.selection.active) { commitSelection(); renderBoard(); }
                    if (state.tool === "polygon") {
                        state.shapes.points = [];
                        state.shapes.current = null;
                        renderBoard();
                    }
                }
                if (e.key === "Enter" && state.tool === "polygon") {
                    if (state.shapes.points.length >= 2) {
                        // History already pushed on first point
                        const pts = getPolygonPoints(state.shapes.points);
                        const hex = getSelectedColor();
                        for (const p of pts) if (inBounds(p.r, p.c)) setCell(p.r, p.c, hex);
                        state.shapes.points = [];
                        state.shapes.current = null;
                        state.dirty = true;
                        renderBoard();
                        renderUsedPanel();
                        autosave();
                    }
                }
                if (e.key === "Delete" || e.key === "Backspace") {
                    if (state.selection.active) {
                        state.selection.active = false;
                        state.selection.floating = null;
                        state.selection.points = [];
                        state.selection.rect = null;
                        state.dirty = true;
                        renderBoard();
                        renderUsedPanel();
                        autosave();
                    }
                }
                const isArrow = ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(e.key);
                if (isArrow && state.selection.active) {
                    e.preventDefault();
                    if (e.key === "ArrowUp") state.selection.oy--;
                    if (e.key === "ArrowDown") state.selection.oy++;
                    if (e.key === "ArrowLeft") state.selection.ox--;
                    if (e.key === "ArrowRight") state.selection.ox++;
                    renderBoard();
                }
            });

            // ===== Status/DocInfo =====
            function updateDocInfo() {
                const total = state.rows * state.cols;
                const used = state.grid.reduce((acc, v) => acc + (normalizeHex(v) ? 1 : 0), 0);
                el.docInfo.textContent = `${state.docName} — ${state.rows}×${state.cols} (${used}/${total} preenchidos) — Paleta: ${state.paletteName}`;
                document.title = `Hama Beads Designer — ${state.docName}`;
            }

            function updateStatus() {
                const sel = state.palette.find(x => x.id === state.selectedColorId);
                const colorTxt = sel ? `${paletteDisplayName(sel)} (${normalizeHex(sel.color)})` : "—";
                const cursorTxt = lastCoordText ? ` | ${lastCoordText}` : "";

                let toolLabel = state.tool;
                if (state.tool === "rectSelect") toolLabel = "Seleção Retangular";
                if (state.tool === "lassoSelect") toolLabel = "Laço";
                if (state.tool === "paint") toolLabel = "Pintar";
                if (state.tool === "bucket") toolLabel = "Balde";
                if (state.tool === "erase") toolLabel = "Borracha";
                if (state.tool === "picker") toolLabel = "Conta-gotas";
                if (state.tool === "line") toolLabel = "Linha";
                if (state.tool === "rect") toolLabel = "Retângulo";
                if (state.tool === "ellipse") toolLabel = "Elipse";
                if (state.tool === "polygon") toolLabel = "Polígono";

                el.statusLeft.textContent = `Ferramenta: ${toolLabel} | Cor: ${colorTxt}${cursorTxt}`;
                // el.statusRight.innerHTML = ... (Removido dicas de atalhos conforme pedido)
                updateDocInfo();

                if (el.toolButtons) {
                    el.toolButtons.forEach(btn => {
                        const t = btn.getAttribute("data-tool");
                        if (["flip-h", "flip-v", "rotate"].includes(t)) return;
                        btn.classList.toggle("active", t === state.tool);
                    });
                }
            }

            // ===== Inicialização =====
            function initFromFullPalette() {
                state.paletteName = "Paleta completa";
                state.palette = FULL_PALETTE.map(p => ({ id: uid(), name: p.name, color: normalizeHex(p.color) || "#ffffff" }));
                state.selectedColorId = state.palette[0]?.id ?? null;
            }

            function initNewDocDefault() {
                state.docName = "Sem título";
                state.rows = 29;
                state.cols = 29;
                state.cellSize = 18;
                state.viewMode = "round";
                state.tool = "paint";
                state.selection.active = false;
                state.selection.floating = null;
                state.selection.points = [];
                initFromFullPalette();
                state.grid = makeEmptyGrid(state.rows, state.cols);
                state.dirty = false;
            }

            if (!tryAutoload()) {
                initNewDocDefault();
                autosave();
            }

            el.viewMode.value = state.viewMode;
            el.cellSize.value = state.cellSize;
            el.cellSizeLabel.textContent = `${state.cellSize} px`;

            renderPalette();
            resizeCanvasToBoard();
            renderUsedPanel();
            updateStatus();
            syncRightToggleUI();
            placeRightToggle();

            // autosave "suave"
            setInterval(() => {
                if (state.dirty) {
                    autosave();
                    state.dirty = false;
                    updateDocInfo();
                }
            }, 1200);
        })();
    </script>
</body>

</html>